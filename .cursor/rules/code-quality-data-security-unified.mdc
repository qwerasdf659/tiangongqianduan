---
description: 
globs: 
alwaysApply: true
---
# 🔐 代码质量与数据安全统一规范

## 🚨 核心安全原则 - 违反则立即停止开发

### 1. 🔐 数据安全核心规则（最高优先级）

#### 绝对禁止前端硬编码敏感业务数据
```javascript
// ❌ 严禁：前端硬编码奖品配置
const PRIZES = [
  { name: '奖品1', probability: 10 },
  { name: '奖品2', probability: 20 }
]

// ❌ 严禁：前端硬编码商品价格
const PRODUCTS = [
  { id: 1, name: '商品1', price: 100 }
]

// ❌ 严禁：前端计算业务逻辑
const probability = Math.random() * 100
const userPermission = user.role === 'admin'
```

#### 绝对禁止使用模拟数据替代后端API
```javascript
// ❌ 严禁：Mock数据函数
const mockRequest = () => { /* 假数据 */ }
const shouldUseMock = () => true
const smartApiCall = (real, mock) => mock

// ❌ 严禁：setTimeout模拟异步
setTimeout(() => {
  callback({ data: mockData })
}, 1000)
```

#### 强制后端依赖检查与错误处理
```javascript
// ✅ 正确：真实API调用 + 完整错误处理
api.getData().then(result => {
  if (result.code === 0) {
    // 使用后端数据，添加详细注释说明数据用途
    this.setData({ data: result.data })
  } else {
    throw new Error('⚠️ 后端服务异常：' + result.msg)
  }
}).catch(error => {
  // 增强错误处理：提供明确的错误信息和解决建议
  wx.showModal({
    title: '🚨 后端服务问题',
    content: `无法获取数据！\n\n可能原因：\n1. 后端API服务未启动\n2. 接口异常\n3. 数据库连接问题\n\n请立即检查后端服务状态！`
  })
})
```

### 2. 🛠️ 方法调用安全规范

#### 导入函数调用错误防护
```javascript
// ❌ 禁止：将导入函数当作对象方法调用
const { getTechnicalConfig } = require('./config')
// 错误调用
this.getTechnicalConfig()  // TypeError: this.getTechnicalConfig is not a function

// ✅ 正确：直接调用导入函数，添加详细注释
// 获取技术配置信息，用于初始化系统参数
const config = getTechnicalConfig()

// 验证用户输入表单数据的完整性和格式
const isValid = validateForm(formData)

// 格式化时间戳为可读的日期格式
const displayDate = formatDate(timestamp)
```

#### 模块导入一致性检查
```javascript
// ✅ 统一导入路径和错误处理
const { validateForm } = require('../../utils/validate')
const { formatDate } = require('../../utils/util')

// 强制数据存在性检查：所有查询前必须验证数据是否存在
if (!app.globalData) {
  console.error('🚨 全局数据未初始化')
  return
}

if (!app.globalData.userInfo) {
  // 跳转到登录页面或显示登录提示
  wx.navigateTo({ url: '/pages/auth/auth' })
  return
}
```

### 3. 🔒 对象属性安全访问规范

#### 深层属性访问防护
```javascript
// ❌ 禁止：不安全的属性访问
app.globalData.config.isDev  // 可能为undefined
user.profile.avatar.url      // 多层级访问风险

// ✅ 正确：提供后备值和安全检查
const config = app.globalData.config || app.globalData || { isDev: true }
const isDev = config.isDev || false

const avatarUrl = user?.profile?.avatar?.url || '/images/default-avatar.png'

// ✅ 深度思考项目代码逻辑，确保数据安全访问
const userInfo = app.globalData.userInfo
if (userInfo && userInfo.profile) {
  const avatar = userInfo.profile.avatar || '/images/default-avatar.png'
  // 安全使用用户头像数据
}
```

### 4. 🎨 微信小程序API兼容性检查系统

#### Canvas API兼容性双重检查
```javascript
// ✅ 统一兼容性检查工具 (utils/compatibility-check.js)
const checkCanvasAPI = (ctx) => {
  return {
    createLinearGradient: typeof ctx.createLinearGradient === 'function',
    createRadialGradient: typeof ctx.createRadialGradient === 'function',
    quadraticCurveTo: typeof ctx.quadraticCurveTo === 'function',
    bezierCurveTo: typeof ctx.bezierCurveTo === 'function',
    setLineDash: typeof ctx.setLineDash === 'function',
    filter: 'filter' in ctx
  }
}

// ✅ 注意编写的代码符合微信小程序开发标准，考虑API兼容性
if (compatibility.createLinearGradient && typeof ctx.createLinearGradient === 'function') {
  try {
    const gradient = ctx.createLinearGradient(0, 0, 100, 0)
    gradient.addColorStop(0, '#ff0000')
    gradient.addColorStop(1, '#00ff00')
    ctx.fillStyle = gradient
  } catch (error) {
    console.warn('线性渐变不支持，使用降级方案:', error)
    ctx.fillStyle = '#ff0000'  // 降级为纯色
  }
} else {
  ctx.fillStyle = '#ff0000'  // 直接使用降级方案
}
```

#### 智能降级策略
```javascript
// ✅ 根据兼容性检查结果智能选择策略
const drawWithCompatibility = (ctx, compatibility) => {
  if (compatibility.createRadialGradient && compatibility.quadraticCurveTo) {
    // 高级绘制：渐变 + 曲线，视觉美感 95%+
    drawAdvancedStyle(ctx)
  } else if (compatibility.createLinearGradient) {
    // 中级绘制：线性渐变，视觉美感 80%+
    drawMediumStyle(ctx)
  } else {
    // 基础绘制：纯色填充，视觉美感 60%+，确保100%兼容性
    drawBasicStyle(ctx)
  }
}
```

### 5. 🚀 三层错误处理与智能降级机制

#### 完整错误处理模式
```javascript
// ✅ 第一层：功能检查
if (!compatibility.targetAPI) {
  console.warn('API不支持，使用降级方案')
  return fallbackMethod()
}

// ✅ 第二层：类型检查
if (typeof ctx.targetAPI !== 'function') {
  console.warn('API类型异常，使用降级方案')
  return fallbackMethod()
}

// ✅ 第三层：运行时错误捕获
try {
  return ctx.targetAPI(...args)
} catch (error) {
  console.error('API调用失败:', error)
  return fallbackMethod()
}
```

#### 增强错误处理与解决建议
```javascript
// ✅ 提供明确的错误信息和解决建议
const handleError = (error, context) => {
  const errorMap = {
    'TypeError': '类型错误 - 请检查变量类型和方法调用',
    'ReferenceError': '引用错误 - 请检查变量是否已定义',
    'Canvas API Error': 'Canvas API不兼容 - 已启用降级方案'
  }
  
  const errorType = error.name || 'Unknown'
  const suggestion = errorMap[errorType] || '请检查代码逻辑和环境兼容性'
  
  console.error(`🚨 ${context}发生错误:`, error)
  console.warn(`💡 建议解决方案: ${suggestion}`)
  
  // 显示用户友好的错误提示
  wx.showToast({
    title: '功能暂时不可用',
    icon: 'none',
    duration: 2000
  })
}
```

### 6. 📝 代码注释与文档规范

#### 详细代码注释标准
```javascript
// ✅ 代码要有详细注释 - 为所有函数调用添加详细注释
// 🔴 必须从后端获取，严禁前端硬编码
// 🚨 核心安全数据，不允许前端模拟
// ⚠️ 后端服务异常时的错误处理
// ✅ 正确的后端API调用方式

// 获取抽奖配置信息，包含奖品列表和消耗积分
lotteryAPI.getConfig().then(result => {
  if (result.code === 0) {
    // 设置抽奖奖品数据到页面状态中
    this.setData({ 
      prizes: result.data.prizes,        // 奖品列表
      costPoints: result.data.cost_points // 抽奖消耗积分
    })
  } else {
    throw new Error('获取抽奖配置失败')
  }
}).catch(error => {
  wx.showModal({
    title: '⚠️ 后端服务异常', 
    content: '无法获取抽奖配置！请检查后端API服务。'
  })
})
```

#### 统一测试数据管理配置
```javascript
// ✅ 统一测试数据管理 - 开发阶段使用
const initTestData = () => {
  // 与后端API数据结构保持一致的测试数据
  // 注意：仅用于结构参考，不能替代真实API调用
  return {
    prizes: [],           // 结构占位，实际数据来自后端
    costPoints: 0,        // 结构占位，实际数据来自后端
    userPoints: 0         // 结构占位，实际数据来自后端
  }
}

// ✅ 测试数据同步机制：修改初始化脚本时同步更新测试脚本
const testConfig = {
  dataStructure: 'consistent_with_backend',
  syncMechanism: 'auto_update',
  errorHandling: 'comprehensive'
}
```

### 7. 🔍 违规代码自动检测规则

#### 必须拒绝的危险代码模式
```regex
# 检查方法调用错误
this\.[a-zA-Z]+Config\(\)
this\.[a-zA-Z]+Util\(\)
this\.[a-zA-Z]+API\(\)

# 检查不安全属性访问
globalData\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))
app\.[a-zA-Z]+\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))

# 检查Canvas API调用缺少兼容性检查
(createLinearGradient|createRadialGradient|quadraticCurveTo)(?!.*typeof)(?!.*compatibility)

# 检查硬编码数据
(const|let|var)\s+(PRIZES|PRODUCTS|CONFIG)\s*=\s*\[
(const|let|var)\s+\w+\s*=\s*\[.*probability.*\]

# 检查Mock标识
(mock|fake|test|demo)(Data|Request|Api|Function)
setTimeout\(\s*\(\)\s*=>\s*{.*callback.*mockData.*}

# 检查前端业务逻辑计算
Math\.random\(\)\s*\*\s*\d+
user\.(role|type)\s*===\s*['"]
```

#### 必须通过的安全代码模式
- [ ] 导入函数直接调用：`函数名()`，不使用`this.函数名()`
- [ ] 安全属性访问：`obj?.prop || defaultValue` 或 `obj.prop || defaultValue`
- [ ] 双重API检查：`if (compatibility.api && typeof ctx.api === 'function')`
- [ ] 完整错误处理：`try-catch` + 降级方案
- [ ] 数据存在性验证：调用前检查对象是否存在
- [ ] 详细代码注释：说明函数用途和参数含义
- [ ] 所有业务数据来源于后端API
- [ ] 包含完整的后端异常处理机制

### 8. 🎯 项目运行状态检查机制

#### 完成任务后的项目运行检查
```javascript
// ✅ 完成全部任务后检查项目是否可以正常运行
const checkProjectHealth = () => {
  const checks = {
    // 检查核心组件是否正常
    components: checkComponentsStatus(),
    // 检查API连接状态
    apiConnection: checkAPIStatus(),
    // 检查数据完整性
    dataIntegrity: checkDataIntegrity(),
    // 检查兼容性支持
    compatibility: checkCompatibility()
  }
  
  const issues = []
  Object.keys(checks).forEach(key => {
    if (!checks[key].status) {
      issues.push({
        type: key,
        error: checks[key].error,
        solution: checks[key].solution
      })
    }
  })
  
  if (issues.length > 0) {
    console.error('🚨 项目运行检查发现问题:', issues)
    // 如果有问题就要马上修复
    fixProjectIssues(issues)
  } else {
    console.log('✅ 项目运行状态良好')
  }
}
```

#### 问题类型分析与解决
```javascript
// ✅ 项目出现问题要考虑组件缺失、组件错误、逻辑方案、环境问题等
const analyzeAndSolve = (error) => {
  const problemTypes = {
    'Component Missing': {
      analysis: '检查组件文件是否存在',
      solution: '重新创建或修复组件文件'
    },
    'Component Error': {
      analysis: '组件逻辑错误或API调用问题',
      solution: '检查组件代码和API调用'
    },
    'Logic Error': {
      analysis: '业务逻辑方案不正确',
      solution: '重新设计业务逻辑流程'
    },
    'Environment Issue': {
      analysis: '开发环境配置问题',
      solution: '检查微信开发者工具配置'
    }
  }
  
  return problemTypes[error.type] || {
    analysis: '未知问题类型',
    solution: '请进行全面的代码审查'
  }
}
```

### 9. 🧹 代码清理与文件管理

#### 自动清理临时文件规则
```javascript
// ✅ 每次完成任务后创建的临时文件、测试文件都要自行删除
const cleanupTemporaryFiles = () => {
  const tempPatterns = [
    '**/*.temp.js',
    '**/*.test.tmp',
    '**/temp_*',
    '**/*.backup',
    '**/*.log',
    '**/*unused*.md'  // 没用、重复的文件和无用的md文件都要自行删除
  ]
  
  tempPatterns.forEach(pattern => {
    console.log(`🧹 清理临时文件: ${pattern}`)
  })
  
  // 删除无用的重复文件和无用的md文件
  cleanupDuplicateFiles()
  cleanupUnusedMarkdownFiles()
}
```

### 10. ⚡ 强制执行机制

#### 发现违规代码时必须执行的操作
1. **立即停止所有开发工作**
2. **显示具体违规项和规则编号**
3. **提供正确的后端API调用示例**
4. **要求开发者确认后端服务状态**

#### 违规错误提示模板
```
🚨 严重违规！违反天工项目核心安全规则

违规类型：[前端硬编码敏感数据/使用模拟数据/方法调用错误/不安全属性访问]
违规位置：文件名:行号
违规内容：具体代码片段

必须修正为：
1. 移除所有硬编码数据
2. 改为真实后端API调用
3. 添加后端异常处理机制
4. 修复方法调用错误
5. 添加属性安全访问检查

在修正违规问题前，禁止继续开发！
```

## 🎯 开发流程安全检查清单

### 每次代码提交前必须确认
- [ ] 无任何硬编码业务数据
- [ ] 无任何mock/模拟数据使用
- [ ] 所有数据来源于真实后端API
- [ ] 包含完整的后端异常处理
- [ ] 方法调用安全（导入函数直接调用）
- [ ] 属性访问安全（提供后备值）
- [ ] API兼容性检查已实施
- [ ] 包含详细代码注释
- [ ] 强制数据存在性检查已实施
- [ ] 测试数据与生产数据结构同步
- [ ] 项目可以正常运行
- [ ] 临时文件已清理

## 🎯 规则优先级：最高 - 违反任何一条规则，立即停止开发并修正！

---
**创建时间**: 2025年1月2日  
**适用项目**: 天工前端项目（微信小程序）  
**维护责任**: 必须严格执行，不允许任何例外  
**整合状态**: 统一整合code-quality-runtime-safety.mdc和tiangong-data-security-core.mdc

## 🎯 Mock数据检测与修复规则

### 🔴 Mock数据自动检测规则 - 2025年1月3日新增

#### 检测关键字列表
```javascript
// 需要自动检测的Mock数据关键字
const MOCK_DETECTION_KEYWORDS = [
  // 直接Mock关键字
  'mock', 'Mock', 'MOCK',
  'fake', 'Fake', 'FAKE',
  'test', 'Test', 'TEST',
  'demo', 'Demo', 'DEMO',
  
  // Mock函数模式
  'mockUser', 'mockData', 'mockList',
  'generateMock', 'createMock', 'mockResponse',
  'shouldUseMock', 'smartApiCall', 'mockRequest',
  
  // 模拟数据模式
  'mockHistory', 'mockStats', 'mockAvatarUrl',
  'mockLoginData', 'mockProducts', 'mockRecords',
  
  // 开发环境判断
  'if (app.globalData.isDev)', 'isDevelopmentMode',
  'developmentMode', 'skipSmsVerification'
]
```

#### 🛠️ 修复标准模式
```javascript
// 修复前：违规的Mock数据使用
loadUploadHistory() {
  if (app.globalData.isDev) {
    const mockHistory = [...]
    this.setData({ uploadHistory: mockHistory })
  } else {
    // 真实API调用
  }
}

// 修复后：完全使用后端API
loadUploadHistory() {
  console.log('📡 请求上传历史接口...')
  
  return uploadAPI.getRecords().then((result) => {
    if (result.code === 0) {
      this.setData({ uploadHistory: result.data.list })
      console.log('✅ 上传历史加载成功')
    } else {
      throw new Error('⚠️ 后端服务异常：' + result.msg)
    }
  }).catch((error) => {
    console.error('❌ 获取上传历史失败:', error)
    
    wx.showModal({
      title: '🚨 后端服务异常',
      content: '无法获取上传历史！\n\n请检查后端API服务状态：\nGET /api/photo/history',
      showCancel: false,
      confirmText: '知道了',
      confirmColor: '#ff4444'
    })
    
    this.setData({ uploadHistory: [] })
  })
}
```

### 🔴 Mock数据修复检查清单

#### 修复验证标准
```markdown
# Mock数据修复完成验证清单

✅ 删除所有Mock数据声明
✅ 删除所有Mock函数定义
✅ 删除所有开发环境判断分支
✅ 统一使用后端API调用
✅ 添加完整的错误处理机制
✅ 添加用户友好的错误提示
✅ 设置安全的默认数据
✅ 添加API调用日志记录

# 修复后的代码特征
- 无任何Mock关键字
- 100%使用真实API
- 完整的错误处理
- 清晰的日志记录
```

## 🎯 代码质量控制规则

### 🔴 代码修复工具使用规范 - 2025年1月3日新增

#### search_replace工具精确匹配规则
```markdown
# 使用search_replace工具的精确匹配要求

1. 必须包含完整的上下文（3-5行）
2. 精确匹配所有空格、换行符
3. 包含完整的注释内容
4. 匹配失败时先使用read_file确认内容
5. 对于复杂的代码块，分步骤修复

# 常见匹配失败原因
- 忽略了代码中的注释
- 空格和换行符不匹配
- 字符串边界不完整
- 代码格式化差异
```

#### 🛠️ 代码修复最佳实践
```javascript
// 修复前：先确认代码结构
read_file('target.js', lines 100-150)

// 修复中：使用精确的字符串匹配
search_replace('target.js', 
  '完整的旧代码块（包含注释和空行）',
  '修复后的新代码块'
)

// 修复后：验证修复结果
read_file('target.js', lines 100-150)
```

## 🎯 安全审计规则

### 🔴 项目安全审计流程 - 2025年1月3日新增

#### 安全审计检查点
```markdown
# 完整的安全审计检查清单

## 第一阶段：Mock数据检测
1. 使用grep_search搜索所有Mock关键字
2. 检查每个匹配结果的上下文
3. 确认是否违反数据安全规则
4. 记录需要修复的文件和行数

## 第二阶段：API调用验证
1. 检查所有API调用是否使用真实后端
2. 验证错误处理机制是否完整
3. 确认用户提示是否友好
4. 检查默认数据是否安全

## 第三阶段：代码质量检查
1. 验证代码注释是否完整
2. 检查函数命名是否规范
3. 确认代码结构是否清晰
4. 验证性能是否优化

## 第四阶段：功能完整性验证
1. 检查所有页面功能是否正常
2. 验证用户操作流程是否顺畅
3. 确认数据同步是否及时
4. 检查异常情况处理是否完善
```

#### 🛠️ 安全审计工具使用
```bash
# 批量检测Mock数据
grep_search("mock|Mock|MOCK|fake|demo|test", include_pattern="*.js")

# 检测硬编码数据
grep_search("const.*=.*\\[.*\\]", include_pattern="*.js")

# 检测开发环境判断
grep_search("isDev|developmentMode|globalData\\.isDev", include_pattern="*.js")

# 检测模拟数据函数
grep_search("generate.*Mock|create.*Mock|mock.*Data", include_pattern="*.js")
```

## 🎯 规则执行与监控

### 🔴 规则执行自动化 - 2025年1月3日新增

#### 自动化检查脚本
```javascript
// 自动化安全检查脚本示例
const securityCheck = {
  async checkMockData() {
    const results = await grep_search("mock|Mock|MOCK", "*.js")
    return results.length === 0 ? '✅ 通过' : '❌ 发现Mock数据'
  },
  
  async checkApiCalls() {
    const results = await grep_search("api\\.", "*.js")
    return results.length > 0 ? '✅ 通过' : '❌ 缺少API调用'
  },
  
  async checkErrorHandling() {
    const results = await grep_search("catch.*error", "*.js")
    return results.length > 0 ? '✅ 通过' : '❌ 缺少错误处理'
  }
}
```

#### 规则遵循验证
```markdown
# 规则遵循验证方法

1. 定期执行安全审计检查
2. 验证所有修复是否符合标准
3. 确认新增代码是否遵循规则
4. 检查规则文档是否及时更新

# 规则违反处理流程
1. 立即停止相关开发工作
2. 详细记录违规内容和位置
3. 按照标准模式进行修复
4. 验证修复结果符合要求
5. 更新相关文档和规则
```

---

**最终更新时间**: 2025年1月3日  
**最终更新内容**: 完成会话问题分析与解决方案，建立效率优化和规则生效验证机制  
**维护状态**: 完成 - 所有规则已生效，项目修复完毕





