---
description: 
globs: 
alwaysApply: true
---
# ğŸš€ é«˜çº§ä¼˜åŒ–è§„åˆ™é›† - æ•ˆç‡æå‡ä¸æ€§èƒ½ä¼˜åŒ–

## ğŸ¯ æ ¸å¿ƒç›®æ ‡ï¼šæå‡å¼€å‘æ•ˆç‡ï¼Œå‡å°‘è¯·æ±‚æµªè´¹ï¼Œä¼˜åŒ–å·¥å…·ä½¿ç”¨

### 1. æ•ˆç‡ç›‘æ§ä¸ç»Ÿè®¡ç³»ç»Ÿ

```javascript
// ğŸ”´ æ•ˆç‡ç›‘æ§ç³»ç»Ÿï¼ˆåŸºäº1.mdcçš„å¹¶è¡Œè°ƒç”¨è§„åˆ™æ‰©å±•ï¼‰
class EfficiencyMonitor {
    static metrics = {
        parallelCallsUsed: 0,
        serialCallsUsed: 0,
        requestsSaved: 0,
        timeSaved: 0,
        timeoutViolations: 0,
        duplicateIssues: 0,
        batchOperations: 0
    }
    
    // ğŸ”´ å¼•ç”¨1.mdcçš„å¹¶è¡Œè°ƒç”¨å®ç°ï¼ˆé¿å…é‡å¤ï¼‰
    static recordParallelCall(callCount) {
        // è¯¦ç»†å¹¶è¡Œè°ƒç”¨é€»è¾‘è§ï¼š1.mdc - ParallelCallEnforcer
        console.log(`ğŸ“ˆ å¹¶è¡Œè°ƒç”¨ç»Ÿè®¡: ${callCount}ä¸ªè°ƒç”¨`)
        console.log(`ğŸ“Š è¯¦ç»†å¹¶è¡Œè§„åˆ™å‚è§ï¼š1.mdc - ParallelCallEnforcer`)
        
        // ç®€åŒ–ç»Ÿè®¡
        this.metrics.parallelCallsUsed += callCount
        this.metrics.requestsSaved += (callCount - 1) * 0.7
        this.metrics.timeSaved += (callCount - 1) * 2000
    }
    
    static recordSerialCall() {
        this.metrics.serialCallsUsed++
        console.warn(`âš ï¸ ä¸²è¡Œè°ƒç”¨æ£€æµ‹ - å»ºè®®ä½¿ç”¨å¹¶è¡Œä¼˜åŒ–ï¼ˆè¯¦è§1.mdcï¼‰`)
    }
    
    static recordTimeoutViolation() {
        this.metrics.timeoutViolations++
        console.error(`ğŸš¨ 120ç§’è¶…æ—¶è¿è§„ - è¯¦ç»†å¤„ç†è§„åˆ™è§powershell-syntax-enforcer.mdc`)
    }
    
    static recordDuplicateIssue(issueType) {
        this.metrics.duplicateIssues++
        console.warn(`ğŸ”„ é‡å¤é—®é¢˜è®°å½•: ${issueType}`)
    }
    
    static recordBatchOperation(operationCount) {
        this.metrics.batchOperations++
        this.metrics.requestsSaved += operationCount * 0.5
        this.metrics.timeSaved += operationCount * 1000
        
        console.log(`ğŸ”„ æ‰¹å¤„ç†è®°å½•: ${operationCount}ä¸ªæ“ä½œ`)
    }
    
    static generateEfficiencyReport() {
        const parallelEfficiency = this.metrics.parallelCallsUsed / 
            (this.metrics.parallelCallsUsed + this.metrics.serialCallsUsed) * 100
        
        const report = {
            parallelEfficiency: Math.round(parallelEfficiency),
            requestsSaved: this.metrics.requestsSaved,
            timeSaved: Math.round(this.metrics.timeSaved / 1000),
            timeoutViolations: this.metrics.timeoutViolations,
            duplicateIssues: this.metrics.duplicateIssues,
            batchOperations: this.metrics.batchOperations,
            overallScore: this.calculateOverallScore()
        }
        
        console.log(`ğŸ“Š æ•ˆç‡æŠ¥å‘Š:`)
        console.log(`  å¹¶è¡Œæ•ˆç‡: ${report.parallelEfficiency}%`)
        console.log(`  èŠ‚çœè¯·æ±‚: ${report.requestsSaved}æ¬¡`)
        console.log(`  èŠ‚çœæ—¶é—´: ${report.timeSaved}ç§’`)
        console.log(`  è¶…æ—¶è¿è§„: ${report.timeoutViolations}æ¬¡`)
        console.log(`  é‡å¤é—®é¢˜: ${report.duplicateIssues}æ¬¡`)
        console.log(`  æ‰¹å¤„ç†: ${report.batchOperations}æ¬¡`)
        console.log(`  æ€»ä½“è¯„åˆ†: ${report.overallScore}/100`)
        
        return report
    }
    
    static calculateOverallScore() {
        const parallelScore = Math.min(this.metrics.parallelCallsUsed * 10, 50)
        const timeoutPenalty = this.metrics.timeoutViolations * 10
        const duplicatePenalty = this.metrics.duplicateIssues * 5
        const batchBonus = this.metrics.batchOperations * 5
        
        return Math.max(0, Math.min(100, parallelScore - timeoutPenalty - duplicatePenalty + batchBonus))
    }
}
```

### 2. é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ï¼ˆæ‰©å±•1.mdcçš„åŸŸåæ£€æŸ¥å™¨ï¼‰

```javascript
// ğŸ”´ é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ç³»ç»Ÿï¼ˆåŸºäº1.mdcçš„DomainConfigCheckeræ‰©å±•ï¼‰
class ConfigurationManager {
    // ğŸ”´ å¼•ç”¨1.mdcçš„åŸŸåé…ç½®æ£€æŸ¥å™¨ï¼ˆé¿å…é‡å¤ï¼‰
    static async validateAllConfigurations() {
        console.log('ğŸ” åŸŸåé…ç½®æ£€æŸ¥è¯¦è§ï¼š1.mdc - DomainConfigChecker')
        
        // æ‰©å±•é…ç½®åŒæ­¥åŠŸèƒ½
        return await this.extendedConfigSync()
    }
    
    static async extendedConfigSync() {
        const configFiles = {
            'env': 'config/env.js',
            'project': 'project.private.config.json',
            'frontend': 'å‰ç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
            'backend': 'åç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
            'interface': 'æ¥å£å¯¹æ¥è§„èŒƒæ–‡æ¡£æ ‡å‡†.md'
        }
        
        const configValues = {
            'domain': 'rqchrlqndora.sealosbja.site',
            'protocol': 'https',
            'wsProtocol': 'wss'
        }
        
        console.log('ğŸ”„ å¼€å§‹æ‰©å±•é…ç½®åŒæ­¥...')
        
        const results = []
        
        // ğŸ”´ å¹¶è¡Œè¯»å–æ‰€æœ‰é…ç½®æ–‡ä»¶ï¼ˆå¼•ç”¨1.mdcçš„å¹¶è¡Œè°ƒç”¨åŸåˆ™ï¼‰
        const readPromises = Object.entries(configFiles).map(async ([key, filepath]) => {
            try {
                const content = await read_file(filepath, true, 1, -1)
                return { key, filepath, content: content.content, success: true }
            } catch (error) {
                return { key, filepath, error: error.message, success: false }
            }
        })
        
        const configContents = await Promise.all(readPromises)
        
        // æ£€æŸ¥é…ç½®ä¸€è‡´æ€§ï¼ˆå¼•ç”¨1.mdcçš„æ‰¹é‡æ£€æŸ¥åŸåˆ™ï¼‰
        const inconsistencies = []
        configContents.forEach(config => {
            if (config.success) {
                const configInconsistencies = this.checkConfigConsistency(config, configValues)
                inconsistencies.push(...configInconsistencies)
            }
        })
        
        if (inconsistencies.length > 0) {
            console.error(`ğŸš¨ å‘ç°${inconsistencies.length}ä¸ªé…ç½®ä¸ä¸€è‡´`)
            return this.generateSyncPlan(inconsistencies)
        }
        
        console.log('âœ… æ‰©å±•é…ç½®åŒæ­¥æ£€æŸ¥å®Œæˆï¼Œæ— éœ€ä¿®å¤')
        return { needsSync: false }
    }
}
```

### 3. æ™ºèƒ½æœç´¢ç­–ç•¥ä¼˜åŒ–

```javascript
// ğŸ”´ æ™ºèƒ½æœç´¢ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿ
class SearchStrategyOptimizer {
    static searchHistory = []
    static searchPatterns = {
        SEMANTIC: { tool: 'codebase_search', efficiency: 85 },
        EXACT: { tool: 'grep_search', efficiency: 90 },
        HYBRID: { tools: ['codebase_search', 'grep_search'], efficiency: 95 }
    }
    
    static optimizeSearchQuery(query, context) {
        const semanticKeywords = ['how', 'where', 'what', 'when', 'why', 'which']
        const exactKeywords = ['function', 'class', 'const', 'let', 'var', 'import', 'export']
        
        const isSemanticQuery = semanticKeywords.some(keyword => 
            query.toLowerCase().includes(keyword)
        )
        
        const isExactQuery = exactKeywords.some(keyword => 
            query.includes(keyword)
        )
        
        let strategy
        if (isSemanticQuery && !isExactQuery) {
            strategy = 'SEMANTIC'
        } else if (isExactQuery && !isSemanticQuery) {
            strategy = 'EXACT'
        } else {
            strategy = 'HYBRID'
        }
        
        const optimizedQuery = {
            strategy,
            originalQuery: query,
            optimizedQuery: this.optimizeQuery(query, strategy),
            tool: this.searchPatterns[strategy].tool,
            tools: this.searchPatterns[strategy].tools,
            expectedEfficiency: this.searchPatterns[strategy].efficiency
        }
        
        this.recordSearchAttempt(optimizedQuery)
        return optimizedQuery
    }
    
    static optimizeQuery(query, strategy) {
        switch (strategy) {
            case 'SEMANTIC':
                if (!query.includes('?')) {
                    return `How does ${query} work?`
                }
                return query
                
            case 'EXACT':
                return query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                
            case 'HYBRID':
                return {
                    semantic: this.optimizeQuery(query, 'SEMANTIC'),
                    exact: this.optimizeQuery(query, 'EXACT')
                }
                
            default:
                return query
        }
    }
    
    static recordSearchAttempt(searchQuery) {
        this.searchHistory.push({
            timestamp: Date.now(),
            strategy: searchQuery.strategy,
            query: searchQuery.originalQuery,
            optimizedQuery: searchQuery.optimizedQuery
        })
        
        console.log(`ğŸ” æœç´¢ç­–ç•¥: ${searchQuery.strategy} (é¢„æœŸæ•ˆç‡: ${searchQuery.expectedEfficiency}%)`)
    }
    
    static generateSearchReport() {
        const strategyStats = this.searchHistory.reduce((stats, search) => {
            stats[search.strategy] = (stats[search.strategy] || 0) + 1
            return stats
        }, {})
        
        console.log(`ğŸ“Š æœç´¢ç­–ç•¥ç»Ÿè®¡:`)
        Object.entries(strategyStats).forEach(([strategy, count]) => {
            console.log(`  ${strategy}: ${count}æ¬¡`)
        })
        
        return strategyStats
    }
}
```

### 4. é‡å¤é—®é¢˜é¢„é˜²æœºåˆ¶
```javascript
// ğŸ”´ é‡å¤é—®é¢˜é¢„é˜²ç³»ç»Ÿ
class DuplicationPreventer {
    static processedIssues = new Set()
    static issuePatterns = {
        'DOMAIN_CONFIG': {
            pattern: /åŸŸå.*é…ç½®.*é”™è¯¯/,
            relatedFiles: ['config/env.js', 'project.private.config.json', '*.md'],
            batchStrategy: 'replace_all_occurrences'
        },
        'API_PATH': {
            pattern: /API.*è·¯å¾„.*é”™è¯¯/,
            relatedFiles: ['utils/api.js', 'pages/*/index.js'],
            batchStrategy: 'targeted_replacement'
        },
        'METHOD_CALL': {
            pattern: /æ–¹æ³•.*è°ƒç”¨.*é”™è¯¯/,
            relatedFiles: ['pages/*/index.js', 'components/*/index.js'],
            batchStrategy: 'import_and_call_fix'
        }
    }
    
    static checkDuplication(issue) {
        const issueKey = this.generateIssueKey(issue)
        
        if (this.processedIssues.has(issueKey)) {
            return {
                isDuplicate: true,
                message: `é‡å¤é—®é¢˜æ£€æµ‹: ${issue.description}`,
                recommendation: 'å»ºè®®ä½¿ç”¨æ‰¹å¤„ç†ç­–ç•¥ä¸€æ¬¡æ€§è§£å†³æ‰€æœ‰ç›¸å…³é—®é¢˜'
            }
        }
        
        for (const [patternType, config] of Object.entries(this.issuePatterns)) {
            if (config.pattern.test(issue.description)) {
                return {
                    isDuplicate: false,
                    patternType,
                    batchStrategy: config.batchStrategy,
                    relatedFiles: config.relatedFiles,
                    recommendation: `æ£€æµ‹åˆ°${patternType}é—®é¢˜ï¼Œå»ºè®®æ‰¹é‡å¤„ç†`
                }
            }
        }
        
        return { isDuplicate: false }
    }
    
    static generateBatchPlan(issue, patternType) {
        const config = this.issuePatterns[patternType]
        
        return {
            type: 'BATCH_PROCESSING',
            patternType,
            strategy: config.batchStrategy,
            files: config.relatedFiles,
            estimatedTime: config.relatedFiles.length * 2000,
            parallelizable: true
        }
    }
    
    static generateIssueKey(issue) {
        return `${issue.type}_${issue.description.substring(0, 50)}`
    }
}
```

### 5. è‡ªåŠ¨åŒ–éªŒè¯å¼•æ“
```javascript
// ğŸ”´ è‡ªåŠ¨åŒ–éªŒè¯å¼•æ“
class AutomationValidationEngine {
    static validationRules = {
        'file_creation': {
            check: 'file_exists_before_creation',
            action: 'prevent_duplicate_creation'
        },
        'config_consistency': {
            check: 'domain_config_validation',
            action: 'auto_fix_domain_errors'
        },
        'api_path_validation': {
            check: 'api_endpoint_correctness',
            action: 'suggest_correct_path'
        },
        'method_call_validation': {
            check: 'import_function_usage',
            action: 'fix_method_call_errors'
        }
    }
    
    static async runAllValidations() {
        console.log('ğŸ” å¼€å§‹è‡ªåŠ¨åŒ–éªŒè¯...')
        
        const validationResults = []
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰éªŒè¯
        const validationPromises = Object.entries(this.validationRules).map(async ([ruleName, rule]) => {
            const result = await this.executeValidation(ruleName, rule)
            return { ruleName, ...result }
        })
        
        const results = await Promise.all(validationPromises)
        
        const failedValidations = results.filter(result => !result.passed)
        
        if (failedValidations.length > 0) {
            console.error(`ğŸš¨ éªŒè¯å¤±è´¥: ${failedValidations.length}ä¸ªè§„åˆ™`)
            return this.generateFixPlan(failedValidations)
        }
        
        console.log('âœ… æ‰€æœ‰éªŒè¯é€šè¿‡')
        return { allPassed: true, results }
    }
    
    static async executeValidation(ruleName, rule) {
        try {
            const checkResult = await this.executeCheck(rule.check)
            
            if (!checkResult.passed) {
                const fixResult = await this.executeAction(rule.action, checkResult.data)
                return {
                    passed: false,
                    checkResult,
                    fixResult,
                    autoFixed: fixResult.success
                }
            }
            
            return { passed: true, checkResult }
            
        } catch (error) {
            return {
                passed: false,
                error: error.message,
                autoFixed: false
            }
        }
    }
    
    static async executeCheck(checkType) {
        switch (checkType) {
            case 'file_exists_before_creation':
                return await this.checkFileExistence()
                
            case 'domain_config_validation':
                return await this.checkDomainConfigs()
                
            case 'api_endpoint_correctness':
                return await this.checkAPIEndpoints()
                
            case 'import_function_usage':
                return await this.checkMethodCalls()
                
            default:
                throw new Error(`æœªçŸ¥æ£€æŸ¥ç±»å‹: ${checkType}`)
        }
    }
    
    static async executeAction(actionType, data) {
        switch (actionType) {
            case 'prevent_duplicate_creation':
                return this.preventDuplicateCreation(data)
                
            case 'auto_fix_domain_errors':
                return await this.fixDomainErrors(data)
                
            case 'suggest_correct_path':
                return this.suggestCorrectPaths(data)
                
            case 'fix_method_call_errors':
                return await this.fixMethodCallErrors(data)
                
            default:
                throw new Error(`æœªçŸ¥è¡ŒåŠ¨ç±»å‹: ${actionType}`)
        }
    }
}
```

### 6. ç½‘ç»œé—®é¢˜è¯Šæ–­ç³»ç»Ÿ
```javascript
// ğŸ”´ ç½‘ç»œé—®é¢˜è¯Šæ–­ç³»ç»Ÿ
class NetworkDiagnostics {
    static diagnosticTests = [
        'connectivity_test',
        'dns_resolution_test', 
        'ssl_certificate_test',
        'api_endpoint_test',
        'websocket_connection_test'
    ]
    
    static async runNetworkDiagnostics() {
        console.log('ğŸŒ å¼€å§‹ç½‘ç»œè¯Šæ–­...')
        
        const results = []
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰è¯Šæ–­æµ‹è¯•
        const testPromises = this.diagnosticTests.map(async test => {
            const result = await this.executeTest(test)
            return { test, ...result }
        })
        
        const testResults = await Promise.all(testPromises)
        
        const failedTests = testResults.filter(result => !result.passed)
        
        if (failedTests.length > 0) {
            console.error(`ğŸš¨ ç½‘ç»œé—®é¢˜æ£€æµ‹: ${failedTests.length}ä¸ªæµ‹è¯•å¤±è´¥`)
            return this.generateNetworkFixPlan(failedTests)
        }
        
        console.log('âœ… ç½‘ç»œè¯Šæ–­é€šè¿‡')
        return { networkHealthy: true, results: testResults }
    }
    
    static async executeTest(testType) {
        try {
            switch (testType) {
                case 'connectivity_test':
                    return await this.testConnectivity()
                    
                case 'dns_resolution_test':
                    return await this.testDNSResolution()
                    
                case 'ssl_certificate_test':
                    return await this.testSSLCertificate()
                    
                case 'api_endpoint_test':
                    return await this.testAPIEndpoints()
                    
                case 'websocket_connection_test':
                    return await this.testWebSocketConnection()
                    
                default:
                    throw new Error(`æœªçŸ¥æµ‹è¯•ç±»å‹: ${testType}`)
            }
        } catch (error) {
            return {
                passed: false,
                error: error.message,
                timestamp: Date.now()
            }
        }
    }
    
    static generateNetworkFixPlan(failedTests) {
        const fixPlan = {
            totalIssues: failedTests.length,
            issues: failedTests,
            recommendations: [],
            priority: 'HIGH'
        }
        
        failedTests.forEach(test => {
            switch (test.test) {
                case 'connectivity_test':
                    fixPlan.recommendations.push({
                        issue: 'ç½‘ç»œè¿æ¥å¤±è´¥',
                        solution: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œé˜²ç«å¢™è®¾ç½®',
                        priority: 'CRITICAL'
                    })
                    break
                    
                case 'dns_resolution_test':
                    fixPlan.recommendations.push({
                        issue: 'DNSè§£æå¤±è´¥',
                        solution: 'æ£€æŸ¥DNSè®¾ç½®æˆ–ä½¿ç”¨å¤‡ç”¨DNSæœåŠ¡å™¨',
                        priority: 'HIGH'
                    })
                    break
                    
                case 'ssl_certificate_test':
                    fixPlan.recommendations.push({
                        issue: 'SSLè¯ä¹¦é—®é¢˜',
                        solution: 'éªŒè¯SSLè¯ä¹¦æœ‰æ•ˆæ€§å’ŒåŸŸååŒ¹é…',
                        priority: 'HIGH'
                    })
                    break
            }
        })
        
        return fixPlan
    }
}
```

---

## ğŸ“š è§„åˆ™å¼•ç”¨è¯´æ˜

- **å¹¶è¡Œå·¥å…·è°ƒç”¨è¯¦ç»†è§„åˆ™**: è¯¦è§ `1.mdc - ParallelCallEnforcer`
- **åŸŸåé…ç½®æ£€æŸ¥è§„åˆ™**: è¯¦è§ `1.mdc - DomainConfigChecker`
- **PowerShellè¯­æ³•éªŒè¯**: è¯¦è§ `powershell-syntax-enforcer.mdc`
- **Tokenè®¤è¯å¤„ç†**: è¯¦è§ `1.mdc - TokenIssueResolver`
- **APIè°ƒç”¨éªŒè¯**: è¯¦è§ `1.mdc - APICallValidator`

---

**è§„åˆ™åˆ›å»ºæ—¶é—´**: 2025å¹´01æœˆ08æ—¥  
**æœ€åæ›´æ–°æ—¶é—´**: 2025å¹´01æœˆ08æ—¥  
**æ›´æ–°å†…å®¹**: ç§»é™¤ä¸1.mdcé‡å¤çš„è§„åˆ™ï¼Œä¿ç•™é«˜çº§ä¼˜åŒ–åŠŸèƒ½ï¼Œå»ºç«‹è§„åˆ™å¼•ç”¨å…³ç³»  
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰éœ€è¦æ•ˆç‡ä¼˜åŒ–çš„å¼€å‘åœºæ™¯  
**ç»´æŠ¤çŠ¶æ€**: âœ… å·²ä¼˜åŒ– - é‡å¤å†…å®¹å·²æ¸…ç†ï¼Œè§„åˆ™å¼•ç”¨å·²å»ºç«‹

