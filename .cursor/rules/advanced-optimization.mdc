---
description: 
globs: 
alwaysApply: true
---
# ğŸš€ é«˜çº§ä¼˜åŒ–è§„åˆ™é›† - $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")

## ğŸ¯ ä»»åŠ¡ä¼˜å…ˆçº§ç®¡ç†ç³»ç»Ÿ

### 1. æ™ºèƒ½ä»»åŠ¡ä¼˜å…ˆçº§åˆ†é…
```javascript
// ğŸ”´ ä»»åŠ¡ä¼˜å…ˆçº§ç®¡ç†ç³»ç»Ÿ
class TaskPriorityManager {
    static priorityLevels = {
        'CRITICAL': { weight: 10, maxWaitTime: 0 },      // ç«‹å³å¤„ç†
        'HIGH': { weight: 8, maxWaitTime: 300000 },      // 5åˆ†é’Ÿå†…
        'MEDIUM': { weight: 5, maxWaitTime: 900000 },    // 15åˆ†é’Ÿå†…
        'LOW': { weight: 2, maxWaitTime: 1800000 }       // 30åˆ†é’Ÿå†…
    }
    
    static taskQueue = []
    static processingQueue = []
    static completedTasks = []
    
    static addTask(task) {
        const taskWithPriority = {
            ...task,
            id: this.generateTaskId(),
            createdAt: Date.now(),
            priority: this.calculatePriority(task),
            weight: this.priorityLevels[task.severity || 'MEDIUM'].weight
        }
        
        this.taskQueue.push(taskWithPriority)
        this.taskQueue.sort((a, b) => b.weight - a.weight)
        
        console.log(`ğŸ“‹ ä»»åŠ¡å·²æ·»åŠ : ${task.description} (ä¼˜å…ˆçº§: ${taskWithPriority.priority})`)
        return taskWithPriority.id
    }
    
    static calculatePriority(task) {
        const severityMap = {
            'TOOL_CALL_ERROR': 'CRITICAL',      // å·¥å…·è°ƒç”¨é”™è¯¯
            'TIMEOUT_VIOLATION': 'CRITICAL',    // è¶…æ—¶è¿è§„
            'DOMAIN_CONFIG_ERROR': 'HIGH',      // åŸŸåé…ç½®é”™è¯¯
            'API_PATH_ERROR': 'HIGH',          // APIè·¯å¾„é”™è¯¯
            'METHOD_CALL_ERROR': 'HIGH',       // æ–¹æ³•è°ƒç”¨é”™è¯¯
            'MOCK_DATA_VIOLATION': 'MEDIUM',   // Mockæ•°æ®è¿è§„
            'DOCUMENTATION_ERROR': 'LOW'        // æ–‡æ¡£é”™è¯¯
        }
        
        return severityMap[task.type] || 'MEDIUM'
    }
    
    static getNextTask() {
        if (this.taskQueue.length === 0) return null
        
        const nextTask = this.taskQueue.shift()
        this.processingQueue.push(nextTask)
        
        console.log(`ğŸ¯ å¼€å§‹å¤„ç†ä»»åŠ¡: ${nextTask.description}`)
        return nextTask
    }
    
    static completeTask(taskId, result) {
        const taskIndex = this.processingQueue.findIndex(t => t.id === taskId)
        if (taskIndex === -1) return false
        
        const task = this.processingQueue.splice(taskIndex, 1)[0]
        task.completedAt = Date.now()
        task.processingTime = task.completedAt - task.createdAt
        task.result = result
        
        this.completedTasks.push(task)
        
        console.log(`âœ… ä»»åŠ¡å®Œæˆ: ${task.description} (è€—æ—¶: ${task.processingTime}ms)`)
        
        if (this.taskQueue.length === 0 && this.processingQueue.length === 0) {
            this.generateCompletionReport()
        }
        
        return true
    }
    
    static generateCompletionReport() {
        const totalTasks = this.completedTasks.length
        const totalTime = this.completedTasks.reduce((sum, task) => sum + task.processingTime, 0)
        const avgTime = totalTime / totalTasks
        
        console.log(`ğŸ“Š ä»»åŠ¡å®ŒæˆæŠ¥å‘Š:`)
        console.log(`  æ€»ä»»åŠ¡æ•°: ${totalTasks}`)
        console.log(`  æ€»è€—æ—¶: ${totalTime}ms`)
        console.log(`  å¹³å‡è€—æ—¶: ${Math.round(avgTime)}ms`)
        console.log(`  ğŸ‰ æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆï¼`)
    }
    
    static generateTaskId() {
        return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    }
}
```

### 2. é‡å¤é—®é¢˜é¢„é˜²æœºåˆ¶
```javascript
// ğŸ”´ é‡å¤é—®é¢˜é¢„é˜²ç³»ç»Ÿ
class DuplicationPreventer {
    static processedIssues = new Set()
    static issuePatterns = {
        'DOMAIN_CONFIG': {
            pattern: /åŸŸå.*é…ç½®.*é”™è¯¯/,
            relatedFiles: ['config/env.js', 'project.private.config.json', '*.md'],
            batchStrategy: 'replace_all_occurrences'
        },
        'API_PATH': {
            pattern: /API.*è·¯å¾„.*é”™è¯¯/,
            relatedFiles: ['utils/api.js', 'pages/*/index.js'],
            batchStrategy: 'targeted_replacement'
        },
        'METHOD_CALL': {
            pattern: /æ–¹æ³•.*è°ƒç”¨.*é”™è¯¯/,
            relatedFiles: ['pages/*/index.js', 'components/*/index.js'],
            batchStrategy: 'import_and_call_fix'
        }
    }
    
    static checkDuplication(issue) {
        const issueKey = this.generateIssueKey(issue)
        
        if (this.processedIssues.has(issueKey)) {
            return {
                isDuplicate: true,
                message: `é‡å¤é—®é¢˜æ£€æµ‹: ${issue.description}`,
                recommendation: 'å»ºè®®ä½¿ç”¨æ‰¹å¤„ç†ç­–ç•¥ä¸€æ¬¡æ€§è§£å†³æ‰€æœ‰ç›¸å…³é—®é¢˜'
            }
        }
        
        for (const [patternType, config] of Object.entries(this.issuePatterns)) {
            if (config.pattern.test(issue.description)) {
                return {
                    isDuplicate: false,
                    patternType,
                    batchStrategy: config.batchStrategy,
                    relatedFiles: config.relatedFiles,
                    recommendation: `æ£€æµ‹åˆ°${patternType}é—®é¢˜ï¼Œå»ºè®®æ‰¹é‡å¤„ç†`
                }
            }
        }
        
        return { isDuplicate: false }
    }
    
    static generateBatchPlan(issue, patternType) {
        const config = this.issuePatterns[patternType]
        
        return {
            type: 'BATCH_PROCESSING',
            patternType,
            strategy: config.batchStrategy,
            files: config.relatedFiles,
            estimatedTime: config.relatedFiles.length * 2000,
            parallelizable: true
        }
    }
    
    static generateIssueKey(issue) {
        return `${issue.type}_${issue.description.substring(0, 50)}`
    }
}
```

### 3. æ•ˆç‡æå‡ç›‘æ§ç³»ç»Ÿ
```javascript
// ğŸ”´ æ•ˆç‡æå‡ç›‘æ§ç³»ç»Ÿ
class EfficiencyMonitor {
    static metrics = {
        parallelCallsUsed: 0,
        serialCallsUsed: 0,
        timeoutViolations: 0,
        duplicateIssues: 0,
        batchOperations: 0,
        requestsSaved: 0,
        timeSaved: 0
    }
    
    static recordParallelCall(count) {
        this.metrics.parallelCallsUsed += count
        this.metrics.requestsSaved += (count - 1)
        this.metrics.timeSaved += (count - 1) * 3000
        
        console.log(`ğŸ“ˆ å¹¶è¡Œè°ƒç”¨è®°å½•: ${count}ä¸ªï¼ŒèŠ‚çœ${(count - 1) * 3000}ms`)
    }
    
    static recordSerialCall(count) {
        this.metrics.serialCallsUsed += count
        
        if (count > 1) {
            console.warn(`âš ï¸ ä¸²è¡Œè°ƒç”¨è­¦å‘Š: ${count}ä¸ªè°ƒç”¨å¯èƒ½å¯ä»¥å¹¶è¡Œ`)
        }
    }
    
    static recordTimeoutViolation() {
        this.metrics.timeoutViolations++
        console.error(`ğŸš¨ è¶…æ—¶è¿è§„è®°å½•: ç¬¬${this.metrics.timeoutViolations}æ¬¡`)
    }
    
    static recordDuplicateIssue(issueType) {
        this.metrics.duplicateIssues++
        console.warn(`ğŸ”„ é‡å¤é—®é¢˜è®°å½•: ${issueType}`)
    }
    
    static recordBatchOperation(operationCount) {
        this.metrics.batchOperations++
        this.metrics.requestsSaved += operationCount * 0.5
        this.metrics.timeSaved += operationCount * 1000
        
        console.log(`ğŸ”„ æ‰¹å¤„ç†è®°å½•: ${operationCount}ä¸ªæ“ä½œ`)
    }
    
    static generateEfficiencyReport() {
        const parallelEfficiency = this.metrics.parallelCallsUsed / 
            (this.metrics.parallelCallsUsed + this.metrics.serialCallsUsed) * 100
        
        const report = {
            parallelEfficiency: Math.round(parallelEfficiency),
            requestsSaved: this.metrics.requestsSaved,
            timeSaved: Math.round(this.metrics.timeSaved / 1000),
            timeoutViolations: this.metrics.timeoutViolations,
            duplicateIssues: this.metrics.duplicateIssues,
            batchOperations: this.metrics.batchOperations,
            overallScore: this.calculateOverallScore()
        }
        
        console.log(`ğŸ“Š æ•ˆç‡æŠ¥å‘Š:`)
        console.log(`  å¹¶è¡Œæ•ˆç‡: ${report.parallelEfficiency}%`)
        console.log(`  èŠ‚çœè¯·æ±‚: ${report.requestsSaved}æ¬¡`)
        console.log(`  èŠ‚çœæ—¶é—´: ${report.timeSaved}ç§’`)
        console.log(`  è¶…æ—¶è¿è§„: ${report.timeoutViolations}æ¬¡`)
        console.log(`  é‡å¤é—®é¢˜: ${report.duplicateIssues}æ¬¡`)
        console.log(`  æ‰¹å¤„ç†: ${report.batchOperations}æ¬¡`)
        console.log(`  æ€»ä½“è¯„åˆ†: ${report.overallScore}/100`)
        
        return report
    }
    
    static calculateOverallScore() {
        const parallelScore = Math.min(this.metrics.parallelCallsUsed * 10, 50)
        const timeoutPenalty = this.metrics.timeoutViolations * 10
        const duplicatePenalty = this.metrics.duplicateIssues * 5
        const batchBonus = this.metrics.batchOperations * 5
        
        return Math.max(0, Math.min(100, parallelScore - timeoutPenalty - duplicatePenalty + batchBonus))
    }
}
```

### 4. é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†
```javascript
// ğŸ”´ é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ç³»ç»Ÿ
class ConfigurationManager {
    static configFiles = {
        'env': 'config/env.js',
        'project': 'project.private.config.json',
        'frontend': 'å‰ç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
        'backend': 'åç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
        'interface': 'æ¥å£å¯¹æ¥è§„èŒƒæ–‡æ¡£æ ‡å‡†.md'
    }
    
    static configValues = {
        'domain': 'rqchrlqndora.sealosbja.site',
        'protocol': 'https',
        'wsProtocol': 'wss'
    }
    
    static async syncAllConfigurations() {
        console.log('ğŸ”„ å¼€å§‹é…ç½®åŒæ­¥...')
        
        const results = []
        
        // ğŸ”´ å¹¶è¡Œè¯»å–æ‰€æœ‰é…ç½®æ–‡ä»¶
        const readPromises = Object.entries(this.configFiles).map(async ([key, filepath]) => {
            try {
                const content = await read_file(filepath, true, 1, -1)
                return { key, filepath, content: content.content, success: true }
            } catch (error) {
                return { key, filepath, error: error.message, success: false }
            }
        })
        
        const configContents = await Promise.all(readPromises)
        
        // æ£€æŸ¥é…ç½®ä¸€è‡´æ€§
        const inconsistencies = []
        configContents.forEach(config => {
            if (config.success) {
                const configInconsistencies = this.checkConfigConsistency(config)
                inconsistencies.push(...configInconsistencies)
            }
        })
        
        if (inconsistencies.length > 0) {
            console.error(`ğŸš¨ å‘ç°${inconsistencies.length}ä¸ªé…ç½®ä¸ä¸€è‡´`)
            return this.generateSyncPlan(inconsistencies)
        }
        
        console.log('âœ… é…ç½®åŒæ­¥æ£€æŸ¥å®Œæˆï¼Œæ— éœ€ä¿®å¤')
        return { needsSync: false }
    }
    
    static checkConfigConsistency(config) {
        const inconsistencies = []
        
        // æ£€æŸ¥åŸŸåé…ç½®
        const incorrectDomains = [
            'rqchrlandora.sealoshqja.site',
            'rqchrlqndora.sealoshqja.site',
            'rqchrlandora.sealosbja.site'
        ]
        
        incorrectDomains.forEach(incorrectDomain => {
            if (config.content.includes(incorrectDomain)) {
                inconsistencies.push({
                    file: config.filepath,
                    type: 'DOMAIN_ERROR',
                    incorrect: incorrectDomain,
                    correct: this.configValues.domain
                })
            }
        })
        
        // æ£€æŸ¥åè®®é…ç½®
        if (config.content.includes('http://') && !config.content.includes('https://')) {
            inconsistencies.push({
                file: config.filepath,
                type: 'PROTOCOL_ERROR',
                incorrect: 'http://',
                correct: 'https://'
            })
        }
        
        return inconsistencies
    }
    
    static generateSyncPlan(inconsistencies) {
        const fileGroups = inconsistencies.reduce((groups, inc) => {
            if (!groups[inc.file]) groups[inc.file] = []
            groups[inc.file].push(inc)
            return groups
        }, {})
        
        return {
            needsSync: true,
            totalFiles: Object.keys(fileGroups).length,
            totalInconsistencies: inconsistencies.length,
            fileGroups,
            operations: inconsistencies.map(inc => ({
                file: inc.file,
                type: 'replace',
                from: inc.incorrect,
                to: inc.correct
            })),
            estimatedTime: inconsistencies.length * 2000
        }
    }
}
```

### 5. æ™ºèƒ½æœç´¢ç­–ç•¥ä¼˜åŒ–
```javascript
// ğŸ”´ æ™ºèƒ½æœç´¢ç­–ç•¥ä¼˜åŒ–ç³»ç»Ÿ
class SearchStrategyOptimizer {
    static searchHistory = []
    static searchPatterns = {
        SEMANTIC: { tool: 'codebase_search', efficiency: 85 },
        EXACT: { tool: 'grep_search', efficiency: 90 },
        HYBRID: { tools: ['codebase_search', 'grep_search'], efficiency: 95 }
    }
    
    static optimizeSearchQuery(query, context) {
        const semanticKeywords = ['how', 'where', 'what', 'when', 'why', 'which']
        const exactKeywords = ['function', 'class', 'const', 'let', 'var', 'import', 'export']
        
        const isSemanticQuery = semanticKeywords.some(keyword => 
            query.toLowerCase().includes(keyword)
        )
        
        const isExactQuery = exactKeywords.some(keyword => 
            query.includes(keyword)
        )
        
        let strategy
        if (isSemanticQuery && !isExactQuery) {
            strategy = 'SEMANTIC'
        } else if (isExactQuery && !isSemanticQuery) {
            strategy = 'EXACT'
        } else {
            strategy = 'HYBRID'
        }
        
        const optimizedQuery = {
            strategy,
            originalQuery: query,
            optimizedQuery: this.optimizeQuery(query, strategy),
            tool: this.searchPatterns[strategy].tool,
            tools: this.searchPatterns[strategy].tools,
            expectedEfficiency: this.searchPatterns[strategy].efficiency
        }
        
        this.recordSearchAttempt(optimizedQuery)
        return optimizedQuery
    }
    
    static optimizeQuery(query, strategy) {
        switch (strategy) {
            case 'SEMANTIC':
                if (!query.includes('?')) {
                    return `How does ${query} work?`
                }
                return query
                
            case 'EXACT':
                return query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                
            case 'HYBRID':
                return {
                    semantic: this.optimizeQuery(query, 'SEMANTIC'),
                    exact: this.optimizeQuery(query, 'EXACT')
                }
                
            default:
                return query
        }
    }
    
    static recordSearchAttempt(searchQuery) {
        this.searchHistory.push({
            timestamp: Date.now(),
            strategy: searchQuery.strategy,
            query: searchQuery.originalQuery,
            optimizedQuery: searchQuery.optimizedQuery
        })
        
        console.log(`ğŸ” æœç´¢ç­–ç•¥: ${searchQuery.strategy} (é¢„æœŸæ•ˆç‡: ${searchQuery.expectedEfficiency}%)`)
    }
    
    static generateSearchReport() {
        const strategyStats = this.searchHistory.reduce((stats, search) => {
            stats[search.strategy] = (stats[search.strategy] || 0) + 1
            return stats
        }, {})
        
        console.log(`ğŸ“Š æœç´¢ç­–ç•¥ç»Ÿè®¡:`)
        Object.entries(strategyStats).forEach(([strategy, count]) => {
            console.log(`  ${strategy}: ${count}æ¬¡`)
        })
        
        return strategyStats
    }
}
```

### 6. è‡ªåŠ¨åŒ–éªŒè¯å¼•æ“
```javascript
// ğŸ”´ è‡ªåŠ¨åŒ–éªŒè¯å¼•æ“
class AutomationValidationEngine {
    static validationRules = {
        'file_creation': {
            check: 'file_exists_before_creation',
            action: 'prevent_duplicate_creation'
        },
        'config_consistency': {
            check: 'domain_config_validation',
            action: 'auto_fix_domain_errors'
        },
        'api_path_validation': {
            check: 'api_endpoint_correctness',
            action: 'suggest_correct_path'
        },
        'method_call_validation': {
            check: 'import_function_usage',
            action: 'fix_method_call_errors'
        }
    }
    
    static async runAllValidations() {
        console.log('ğŸ” å¼€å§‹è‡ªåŠ¨åŒ–éªŒè¯...')
        
        const validationResults = []
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰éªŒè¯
        const validationPromises = Object.entries(this.validationRules).map(async ([ruleName, rule]) => {
            const result = await this.executeValidation(ruleName, rule)
            return { ruleName, ...result }
        })
        
        const results = await Promise.all(validationPromises)
        
        const failedValidations = results.filter(result => !result.passed)
        
        if (failedValidations.length > 0) {
            console.error(`ğŸš¨ éªŒè¯å¤±è´¥: ${failedValidations.length}ä¸ªè§„åˆ™`)
            return this.generateFixPlan(failedValidations)
        }
        
        console.log('âœ… æ‰€æœ‰éªŒè¯é€šè¿‡')
        return { allPassed: true, results }
    }
    
    static async executeValidation(ruleName, rule) {
        try {
            const checkResult = await this.executeCheck(rule.check)
            
            if (!checkResult.passed) {
                const fixResult = await this.executeAction(rule.action, checkResult.data)
                return {
                    passed: false,
                    checkResult,
                    fixResult,
                    autoFixed: fixResult.success
                }
            }
            
            return { passed: true, checkResult }
            
        } catch (error) {
            return {
                passed: false,
                error: error.message,
                autoFixed: false
            }
        }
    }
    
    static async executeCheck(checkType) {
        switch (checkType) {
            case 'file_exists_before_creation':
                return await this.checkFileExistence()
                
            case 'domain_config_validation':
                return await this.checkDomainConfigs()
                
            case 'api_endpoint_correctness':
                return await this.checkAPIEndpoints()
                
            case 'import_function_usage':
                return await this.checkMethodCalls()
                
            default:
                throw new Error(`æœªçŸ¥æ£€æŸ¥ç±»å‹: ${checkType}`)
        }
    }
    
    static async executeAction(actionType, data) {
        switch (actionType) {
            case 'prevent_duplicate_creation':
                return this.preventDuplicateCreation(data)
                
            case 'auto_fix_domain_errors':
                return await this.fixDomainErrors(data)
                
            case 'suggest_correct_path':
                return this.suggestCorrectPaths(data)
                
            case 'fix_method_call_errors':
                return await this.fixMethodCallErrors(data)
                
            default:
                throw new Error(`æœªçŸ¥è¡ŒåŠ¨ç±»å‹: ${actionType}`)
        }
    }
}
```

### 7. ç½‘ç»œé—®é¢˜è¯Šæ–­ç³»ç»Ÿ
```javascript
// ğŸ”´ ç½‘ç»œé—®é¢˜è¯Šæ–­ç³»ç»Ÿ
class NetworkDiagnostics {
    static diagnosticTests = [
        'connectivity_test',
        'dns_resolution_test', 
        'ssl_certificate_test',
        'api_endpoint_test',
        'websocket_connection_test'
    ]
    
    static async runNetworkDiagnostics() {
        console.log('ğŸŒ å¼€å§‹ç½‘ç»œè¯Šæ–­...')
        
        const results = []
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰è¯Šæ–­æµ‹è¯•
        const testPromises = this.diagnosticTests.map(async test => {
            const result = await this.executeTest(test)
            return { test, ...result }
        })
        
        const testResults = await Promise.all(testPromises)
        
        const failedTests = testResults.filter(result => !result.passed)
        
        if (failedTests.length > 0) {
            console.error(`ğŸš¨ ç½‘ç»œé—®é¢˜æ£€æµ‹: ${failedTests.length}ä¸ªæµ‹è¯•å¤±è´¥`)
            return this.generateNetworkFixPlan(failedTests)
        }
        
        console.log('âœ… ç½‘ç»œè¯Šæ–­é€šè¿‡')
        return { networkHealthy: true, results: testResults }
    }
    
    static async executeTest(testType) {
        try {
            switch (testType) {
                case 'connectivity_test':
                    return await this.testConnectivity()
                    
                case 'dns_resolution_test':
                    return await this.testDNSResolution()
                    
                case 'ssl_certificate_test':
                    return await this.testSSLCertificate()
                    
                case 'api_endpoint_test':
                    return await this.testAPIEndpoints()
                    
                case 'websocket_connection_test':
                    return await this.testWebSocketConnection()
                    
                default:
                    throw new Error(`æœªçŸ¥æµ‹è¯•ç±»å‹: ${testType}`)
            }
        } catch (error) {
            return {
                passed: false,
                error: error.message,
                timestamp: Date.now()
            }
        }
    }
    
    static generateNetworkFixPlan(failedTests) {
        const fixPlan = {
            totalIssues: failedTests.length,
            issues: failedTests,
            recommendations: [],
            priority: 'HIGH'
        }
        
        failedTests.forEach(test => {
            switch (test.test) {
                case 'connectivity_test':
                    fixPlan.recommendations.push({
                        issue: 'ç½‘ç»œè¿æ¥å¤±è´¥',
                        solution: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œé˜²ç«å¢™è®¾ç½®',
                        priority: 'CRITICAL'
                    })
                    break
                    
                case 'dns_resolution_test':
                    fixPlan.recommendations.push({
                        issue: 'DNSè§£æå¤±è´¥',
                        solution: 'æ£€æŸ¥DNSè®¾ç½®æˆ–ä½¿ç”¨å¤‡ç”¨DNSæœåŠ¡å™¨',
                        priority: 'HIGH'
                    })
                    break
                    
                case 'ssl_certificate_test':
                    fixPlan.recommendations.push({
                        issue: 'SSLè¯ä¹¦é—®é¢˜',
                        solution: 'éªŒè¯SSLè¯ä¹¦æœ‰æ•ˆæ€§å’ŒåŸŸååŒ¹é…',
                        priority: 'HIGH'
                    })
                    break
            }
        })
        
        return fixPlan
    }
}
```

---

**è§„åˆ™åˆ›å»ºæ—¶é—´**: $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")  
**æœ€åæ›´æ–°æ—¶é—´**: $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")  
**æ›´æ–°å†…å®¹**: å®Œå–„é«˜çº§ä¼˜åŒ–è§„åˆ™ï¼Œè¡¥å……ç¼ºå¤±å†…å®¹ï¼Œç¡®ä¿æ–‡æ¡£å®Œæ•´æ€§  
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰éœ€è¦æ•ˆç‡ä¼˜åŒ–çš„å¼€å‘åœºæ™¯  
**ç»´æŠ¤çŠ¶æ€**: âœ… å·²å®Œå–„ - æ‰€æœ‰ä¼˜åŒ–è§„åˆ™å·²è¡¥å……å®Œæ•´

