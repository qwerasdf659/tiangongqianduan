---
description: 
globs: 
alwaysApply: true
---
# 🔐 天工项目安全与质量标准规范 - 核心安全规则集

## 🚨 核心安全原则 - 违反则立即停止开发

### 1. 🔐 数据安全核心规则（最高优先级）

#### 绝对禁止前端硬编码敏感业务数据
```javascript
// ❌ 严禁：前端硬编码奖品配置
const PRIZES = [
  { name: '奖品1', probability: 10 },
  { name: '奖品2', probability: 20 }
]

// ❌ 严禁：前端硬编码商品价格
const PRODUCTS = [
  { id: 1, name: '商品1', price: 100 }
]

// ❌ 严禁：前端计算业务逻辑
const probability = Math.random() * 100
const userPermission = user.role === 'admin'
```

#### 绝对禁止使用模拟数据替代后端API
```javascript
// ❌ 严禁：Mock数据函数
const mockRequest = () => { /* 假数据 */ }
const shouldUseMock = () => true
const smartApiCall = (real, mock) => mock

// ❌ 严禁：setTimeout模拟异步
setTimeout(() => {
  callback({ data: mockData })
}, 1000)
```

#### 强制后端依赖检查与错误处理
```javascript
// ✅ 正确：真实API调用 + 完整错误处理
api.getData().then(result => {
  if (result.code === 0) {
    this.setData({ data: result.data })
  } else {
    throw new Error('⚠️ 后端服务异常：' + result.msg)
  }
}).catch(error => {
  wx.showModal({
    title: '🚨 后端服务问题',
    content: `无法获取数据！\n\n可能原因：\n1. 后端API服务未启动\n2. 接口异常\n3. 数据库连接问题\n\n请立即检查后端服务状态！`
  })
})
```

### 2. 🛠️ 方法调用安全规范

#### 导入函数调用错误防护
```javascript
// ❌ 禁止：将导入函数当作对象方法调用
const { getTechnicalConfig } = require('./config')
// 错误调用
this.getTechnicalConfig()  // TypeError: this.getTechnicalConfig is not a function

// ✅ 正确：直接调用导入函数，添加详细注释
const config = getTechnicalConfig()  // 获取技术配置信息
const isValid = validateForm(formData)  // 验证用户输入表单数据
const displayDate = formatDate(timestamp)  // 格式化时间戳
```

#### 模块导入一致性检查
```javascript
// ✅ 统一导入路径和错误处理
const { validateForm } = require('../../utils/validate')
const { formatDate } = require('../../utils/util')

// 强制数据存在性检查：所有查询前必须验证数据是否存在
if (!app.globalData) {
  console.error('🚨 全局数据未初始化')
  return
}

if (!app.globalData.userInfo) {
  wx.navigateTo({ url: '/pages/auth/auth' })
  return
}
```

### 3. 🔒 对象属性安全访问规范

#### 深层属性访问防护
```javascript
// ❌ 禁止：不安全的属性访问
app.globalData.config.isDev  // 可能为undefined
user.profile.avatar.url      // 多层级访问风险

// ✅ 正确：提供后备值和安全检查
const config = app.globalData.config || app.globalData || { isDev: true }
const isDev = config.isDev || false

const avatarUrl = user?.profile?.avatar?.url || '/images/default-avatar.png'

// ✅ 深度思考项目代码逻辑，确保数据安全访问
const userInfo = app.globalData.userInfo
if (userInfo && userInfo.profile) {
  const avatar = userInfo.profile.avatar || '/images/default-avatar.png'
}
```

### 4. 🎨 微信小程序API兼容性检查系统

#### Canvas API兼容性双重检查
```javascript
// ✅ 统一兼容性检查工具 (utils/compatibility-check.js)
const checkCanvasAPI = (ctx) => {
  return {
    createLinearGradient: typeof ctx.createLinearGradient === 'function',
    createRadialGradient: typeof ctx.createRadialGradient === 'function',
    quadraticCurveTo: typeof ctx.quadraticCurveTo === 'function',
    bezierCurveTo: typeof ctx.bezierCurveTo === 'function',
    setLineDash: typeof ctx.setLineDash === 'function',
    filter: 'filter' in ctx
  }
}

// ✅ 注意编写的代码符合微信小程序开发标准，考虑API兼容性
if (compatibility.createLinearGradient && typeof ctx.createLinearGradient === 'function') {
  try {
    const gradient = ctx.createLinearGradient(0, 0, 100, 0)
    gradient.addColorStop(0, '#ff0000')
    gradient.addColorStop(1, '#00ff00')
    ctx.fillStyle = gradient
  } catch (error) {
    console.warn('线性渐变不支持，使用降级方案:', error)
    ctx.fillStyle = '#ff0000'
  }
} else {
  ctx.fillStyle = '#ff0000'
}
```

#### 智能降级策略
```javascript
// ✅ 根据兼容性检查结果智能选择策略
const drawWithCompatibility = (ctx, compatibility) => {
  if (compatibility.createRadialGradient && compatibility.quadraticCurveTo) {
    drawAdvancedStyle(ctx)  // 高级绘制：渐变 + 曲线，视觉美感 95%+
  } else if (compatibility.createLinearGradient) {
    drawMediumStyle(ctx)    // 中级绘制：线性渐变，视觉美感 80%+
  } else {
    drawBasicStyle(ctx)     // 基础绘制：纯色填充，视觉美感 60%+，确保100%兼容性
  }
}
```

### 5. 🚀 三层错误处理与智能降级机制

#### 完整错误处理模式
```javascript
// ✅ 第一层：功能检查
if (!compatibility.targetAPI) {
  console.warn('API不支持，使用降级方案')
  return fallbackMethod()
}

// ✅ 第二层：类型检查
if (typeof ctx.targetAPI !== 'function') {
  console.warn('API类型异常，使用降级方案')
  return fallbackMethod()
}

// ✅ 第三层：运行时错误捕获
try {
  return ctx.targetAPI(...args)
} catch (error) {
  console.error('API调用失败:', error)
  return fallbackMethod()
}
```

#### 增强错误处理与解决建议
```javascript
// ✅ 提供明确的错误信息和解决建议
const handleError = (error, context) => {
  const errorMap = {
    'TypeError': '类型错误 - 请检查变量类型和方法调用',
    'ReferenceError': '引用错误 - 请检查变量是否已定义',
    'Canvas API Error': 'Canvas API不兼容 - 已启用降级方案'
  }
  
  const errorType = error.name || 'Unknown'
  const suggestion = errorMap[errorType] || '请检查代码逻辑和环境兼容性'
  
  console.error(`🚨 ${context}发生错误:`, error)
  console.warn(`💡 建议解决方案: ${suggestion}`)
  
  wx.showToast({
    title: '功能暂时不可用',
    icon: 'none',
    duration: 2000
  })
}
```

### 6. 📝 代码注释与文档规范

#### 详细代码注释标准
```javascript
// ✅ 代码要有详细注释 - 为所有函数调用添加详细注释
// 🔴 必须从后端获取，严禁前端硬编码
// 🚨 核心安全数据，不允许前端模拟
// ⚠️ 后端服务异常时的错误处理
// ✅ 正确的后端API调用方式

// 获取抽奖配置信息，包含奖品列表和消耗积分
lotteryAPI.getConfig().then(result => {
  if (result.code === 0) {
    this.setData({ 
      prizes: result.data.prizes,        // 奖品列表
      costPoints: result.data.cost_points // 抽奖消耗积分
    })
  } else {
    throw new Error('获取抽奖配置失败')
  }
}).catch(error => {
  wx.showModal({
    title: '⚠️ 后端服务异常', 
    content: '无法获取抽奖配置！请检查后端API服务。'
  })
})
```

### 7. 🔍 Mock数据安全检测与防护

#### Mock数据检测器 - 完善版
```javascript
// 🔴 Mock数据检测器
class MockDataDetector {
    constructor() {
        this.mockKeywords = [
            'mock', 'Mock', 'MOCK', 'fake', 'Fake', 'FAKE',
            'test', 'Test', 'TEST', 'demo', 'Demo', 'DEMO',
            'sample', 'Sample', 'SAMPLE', 'dummy', 'Dummy', 'DUMMY',
            'mockData', 'mockAPI', 'mockResponse',
            'fakeData', 'fakeAPI', 'fakeResponse',
            'testData', 'testAPI', 'testResponse',
            'shouldUseMock', 'useMockData', 'isMockMode'
        ]
        
        this.mockPatterns = [
            /const\s+mock\w+\s*=/gi,
            /function\s+mock\w+/gi,
            /if\s*\(\s*\w*mock\w*/gi,
            /setTimeout\s*\(\s*\(\)\s*=>\s*{[\s\S]*?callback/gi,
            /const\s+\w+\s*=\s*\[[\s\S]*?\]/gi
        ]
    }
    
    // 🔴 全面检测Mock数据
    detectMockData(fileContent, filePath) {
        const violations = []
        
        // 检测关键词
        for (const keyword of this.mockKeywords) {
            if (fileContent.includes(keyword)) {
                const lines = this.findLinesWithKeyword(fileContent, keyword)
                violations.push({
                    type: 'MOCK_KEYWORD',
                    keyword: keyword,
                    file: filePath,
                    lines: lines,
                    severity: 'HIGH'
                })
            }
        }
        
        // 检测模式
        for (const pattern of this.mockPatterns) {
            const matches = fileContent.match(pattern)
            if (matches) {
                violations.push({
                    type: 'MOCK_PATTERN',
                    pattern: pattern.toString(),
                    matches: matches,
                    file: filePath,
                    severity: 'CRITICAL'
                })
            }
        }
        
        return violations
    }
    
    // 🔴 生成修复建议
    generateFixSuggestions(violations) {
        const suggestions = []
        
        for (const violation of violations) {
            switch (violation.type) {
                case 'MOCK_KEYWORD':
                    suggestions.push({
                        file: violation.file,
                        lines: violation.lines,
                        suggestion: `移除Mock关键词"${violation.keyword}"，使用真实API调用`,
                        example: 'api.getData().then(result => { /* 使用真实数据 */ })'
                    })
                    break
                    
                case 'MOCK_PATTERN':
                    suggestions.push({
                        file: violation.file,
                        suggestion: '移除Mock函数/条件判断，直接调用后端API',
                        example: '直接使用：userAPI.login(params) 替代 mockLogin(params)'
                    })
                    break
            }
        }
        
        return suggestions
    }
    
    findLinesWithKeyword(content, keyword) {
        const lines = content.split('\n')
        const matchingLines = []
        
        lines.forEach((line, index) => {
            if (line.includes(keyword)) {
                matchingLines.push(index + 1)
            }
        })
        
        return matchingLines
    }
}
```

#### 生产环境Mock数据零容忍
```javascript
// ✅ 建立Mock数据检测机制
const mockDetector = new MockDataDetector()

// 🔴 批量检测项目中的Mock数据
const scanProjectForMockData = async (projectPath) => {
    const jsFiles = await getAllJSFiles(projectPath)
    const results = []
    
    for (const filePath of jsFiles) {
        const content = await fs.readFile(filePath, 'utf8')
        const detection = mockDetector.detectMockData(content, filePath)
        
        if (detection.length > 0) {
            results.push({ filePath, violations: detection })
        }
    }
    
    return {
        totalFiles: jsFiles.length,
        violationFiles: results.length,
        totalViolations: results.reduce((sum, r) => sum + r.violations.length, 0),
        results: results
    }
}
```

### 8. 🔐 认证与权限安全强化

#### Token管理安全标准
```javascript
// ✅ JWT Token自动刷新机制
const tokenManager = {
    // 检查Token是否即将过期（30秒内）
    checkTokenExpiry() {
        const token = app.globalData.accessToken
        if (!token) return false
        
        try {
            const payload = JSON.parse(atob(token.split('.')[1]))
            const expiryTime = payload.exp * 1000
            const currentTime = Date.now()
            
            return (expiryTime - currentTime) < 30000 // 30秒内过期
        } catch (error) {
            console.error('Token解析失败:', error)
            return true // 解析失败视为过期
        }
    },
    
    // 自动刷新Token
    async refreshTokenIfNeeded() {
        if (this.checkTokenExpiry()) {
            console.log('🔄 Token即将过期，自动刷新...')
            try {
                const result = await authAPI.refresh(app.globalData.refreshToken)
                if (result.code === 0) {
                    app.globalData.accessToken = result.data.access_token
                    app.globalData.refreshToken = result.data.refresh_token
                    console.log('✅ Token刷新成功')
                } else {
                    throw new Error('Token刷新失败')
                }
            } catch (error) {
                console.error('❌ Token刷新失败，需要重新登录:', error)
                app.logout()
            }
        }
    }
}
```

#### 权限验证增强
```javascript
// ✅ 每个API调用前验证Token有效性
const secureAPICall = async (apiFunction, params) => {
    // 检查并刷新Token
    await tokenManager.refreshTokenIfNeeded()
    
    // 验证用户权限
    if (!app.globalData.accessToken) {
        throw new Error('用户未登录')
    }
    
    try {
        return await apiFunction(params)
    } catch (error) {
        if (error.code === 401) {
            console.log('🔐 认证失败，尝试刷新Token...')
            await tokenManager.refreshTokenIfNeeded()
            return await apiFunction(params) // 重试一次
        }
        throw error
    }
}
```

### 9. 🛡️ 数据传输与存储安全

#### API通信安全标准
```javascript
// ✅ 强制HTTPS传输检查
const secureRequest = (options) => {
    const { url } = options
    
    // 检查HTTPS
    if (!url.startsWith('https://') && !url.startsWith('wss://')) {
        console.warn('⚠️ 检测到非HTTPS传输，存在安全风险')
        
        // 生产环境强制HTTPS
        if (!app.globalData.isDev) {
            throw new Error('生产环境必须使用HTTPS传输')
        }
    }
    
    // 添加安全头
    const secureHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Client-Type': 'miniprogram',
        'X-Client-Version': app.globalData.version,
        'X-Request-ID': generateRequestId(),
        'X-Timestamp': Date.now().toString()
    }
    
    return {
        ...options,
        header: { ...secureHeaders, ...options.header }
    }
}
```

#### 本地数据安全存储
```javascript
// ✅ 敏感数据加密存储
const secureStorage = {
    // 加密存储敏感数据
    setSecureItem(key, value) {
        try {
            const encryptedValue = this.encrypt(JSON.stringify(value))
            wx.setStorageSync(key, encryptedValue)
        } catch (error) {
            console.error('加密存储失败:', error)
        }
    },
    
    // 解密读取敏感数据
    getSecureItem(key) {
        try {
            const encryptedValue = wx.getStorageSync(key)
            if (!encryptedValue) return null
            
            const decryptedValue = this.decrypt(encryptedValue)
            return JSON.parse(decryptedValue)
        } catch (error) {
            console.error('解密读取失败:', error)
            return null
        }
    },
    
    // 简单加密（实际项目中应使用更强的加密算法）
    encrypt(text) {
        return btoa(encodeURIComponent(text))
    },
    
    // 简单解密
    decrypt(encryptedText) {
        return decodeURIComponent(atob(encryptedText))
    }
}
```

### 10. 🚨 错误状态下数据安全处理

#### 严禁生成模拟数据
```javascript
// ✅ 错误降级机制：显示空状态而非虚假数据
const handleDataLoadError = (error, context) => {
    console.error(`❌ ${context}数据加载失败:`, error)
    
    // 🚨 严禁生成模拟数据
    // ❌ 错误做法：return { data: mockData }
    
    // ✅ 正确做法：明确告知错误来源和类型
    let errorSource = '未知'
    let errorType = '数据获取失败'
    
    if (error.code >= 1000 && error.code < 2000) {
        errorSource = '业务逻辑'
        errorType = '业务规则验证失败'
    } else if (error.code >= 2000 && error.code < 3000) {
        errorSource = '后端服务'
        errorType = '服务器处理异常'
    } else if (error.code >= 3000) {
        errorSource = '数据库'
        errorType = '数据查询失败'
    } else if (error.name === 'NetworkError') {
        errorSource = '网络连接'
        errorType = '网络连接中断'
    }
    
    // 显示明确的错误提示
    wx.showModal({
        title: `🚨 ${errorSource}错误`,
        content: `❌ 错误来源：${errorSource}\n📝 错误类型：${errorType}\n🔗 错误详情：${error.message || '未知错误'}\n\n🚨 严禁生成模拟结果！\n请联系技术人员检查${errorSource}问题。`,
        showCancel: false,
        confirmText: '知道了',
        confirmColor: '#ff4444'
    })
    
    // 返回空状态，明确标识数据来源
    return {
        data: null,
        error: true,
        errorSource: errorSource,
        errorType: errorType,
        message: `${errorSource}服务异常，无法获取数据`
    }
}
```

### 11. 🔍 违规代码自动检测规则

#### 必须拒绝的危险代码模式
```javascript
// 🔴 代码安全检测器
class CodeSecurityDetector {
    constructor() {
        this.dangerousPatterns = [
            // 方法调用错误
            /this\.[a-zA-Z]+Config\(\)/g,
            /this\.[a-zA-Z]+Util\(\)/g,
            /this\.[a-zA-Z]+API\(\)/g,
            
            // 不安全属性访问
            /globalData\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))/g,
            /app\.[a-zA-Z]+\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))/g,
            
            // Canvas API调用缺少兼容性检查
            /(createLinearGradient|createRadialGradient|quadraticCurveTo)(?!.*typeof)(?!.*compatibility)/g,
            
            // 硬编码数据
            /(const|let|var)\s+(PRIZES|PRODUCTS|CONFIG)\s*=\s*\[/g,
            /(const|let|var)\s+\w+\s*=\s*\[.*probability.*\]/g,
            
            // Mock标识
            /(mock|fake|test|demo)(Data|Request|Api|Function)/gi,
            /setTimeout\(\s*\(\)\s*=>\s*{.*callback.*mockData.*}/g,
            
            // 前端业务逻辑计算
            /Math\.random\(\)\s*\*\s*\d+/g,
            /user\.(role|type)\s*===\s*['"]/g
        ]
    }
    
    // 检测危险代码模式
    detectDangerousCode(code) {
        const violations = []
        
        this.dangerousPatterns.forEach((pattern, index) => {
            const matches = code.match(pattern)
            if (matches) {
                violations.push({
                    patternIndex: index,
                    pattern: pattern.source,
                    matches: matches,
                    severity: this.getSeverity(index)
                })
            }
        })
        
        return violations
    }
    
    getSeverity(patternIndex) {
        if (patternIndex < 6) return 'CRITICAL'
        if (patternIndex < 10) return 'HIGH'
        return 'MEDIUM'
    }
}
```

### 12. 🎯 项目运行状态检查机制

#### 完成任务后的项目运行检查
```javascript
// ✅ 完成全部任务后检查项目是否可以正常运行
const checkProjectHealth = () => {
  const checks = {
    components: checkComponentsStatus(),     // 检查核心组件
    apiConnection: checkAPIStatus(),        // 检查API连接状态
    dataIntegrity: checkDataIntegrity(),    // 检查数据完整性
    compatibility: checkCompatibility()     // 检查兼容性支持
  }
  
  const issues = []
  Object.keys(checks).forEach(key => {
    if (!checks[key].status) {
      issues.push({
        type: key,
        error: checks[key].error,
        solution: checks[key].solution
      })
    }
  })
  
  if (issues.length > 0) {
    console.error('🚨 项目运行检查发现问题:', issues)
    fixProjectIssues(issues)  // 如果有问题就要马上修复
  } else {
    console.log('✅ 项目运行状态良好')
  }
}

// 问题类型分析与解决
const analyzeAndSolve = (error) => {
  const problemTypes = {
    'Component Missing': {
      analysis: '检查组件文件是否存在',
      solution: '重新创建或修复组件文件'
    },
    'Component Error': {
      analysis: '组件逻辑错误或API调用问题',
      solution: '检查组件代码和API调用'
    },
    'Logic Error': {
      analysis: '业务逻辑方案不正确',
      solution: '重新设计业务逻辑流程'
    },
    'Environment Issue': {
      analysis: '开发环境配置问题',
      solution: '检查微信开发者工具配置'
    }
  }
  
  return problemTypes[error.type] || {
    analysis: '未知问题类型',
    solution: '请进行全面的代码审查'
  }
}
```

### 13. 🧹 代码清理与文件管理

#### 自动清理临时文件规则
```javascript
// ✅ 每次完成任务后创建的临时文件、测试文件都要自行删除
const cleanupTemporaryFiles = () => {
  const tempPatterns = [
    '**/*.temp.js',
    '**/*.test.tmp',
    '**/temp_*',
    '**/*.backup',
    '**/*.log',
    '**/*unused*.md'  // 没用、重复的文件和无用的md文件都要自行删除
  ]
  
  tempPatterns.forEach(pattern => {
    console.log(`🧹 清理临时文件: ${pattern}`)
  })
  
  cleanupDuplicateFiles()
  cleanupUnusedMarkdownFiles()
}
```

## 📚 相关规则文档引用

- **PowerShell控制台稳定性**: 详见 `development-automation-unified.mdc`
- **工具调用参数验证**: 详见 `1.mdc` - 工具调用参数验证规则
- **并行工具调用优化**: 详见 `1.mdc` - 并行工具调用强制优化规则
- **微信小程序项目识别**: 详见 `development-automation-unified.mdc`
- **信息收集策略**: 详见 `development-automation-unified.mdc`

---

**规则创建时间**: 2025年01月03日  
**最后更新时间**: 2025年01月03日  
**更新内容**: 整理合并重复内容，保留核心安全规则，优化Mock数据检测系统  
**适用范围**: 天工项目所有开发活动  
**维护状态**: ✅ 已整理 - 重复内容已合并，安全规则完整性已保证

## 🚨 2025年01月03日会话问题分析新增安全规则

### 7. 🌐 域名配置安全规则
```javascript
// 🔴 域名配置安全检查 - 预防域名拼写错误导致的安全问题
class DomainSecurityChecker {
    constructor() {
        this.trustedDomains = {
            'rqchrlqndora.sealosbja.site': {
                environment: 'production',
                ssl: true,
                protocols: ['https', 'wss'],
                verified: true
            }
        }
        
        this.suspiciousDomains = [
            'rqchrlandora.sealoshqja.site',    // 钓鱼域名可能性
            'rqchrlqndora.sealoshqja.site',    // 拼写错误域名
            'rqchrlandora.sealosbja.site'      // 类似域名
        ]
    }
    
    // 🔴 检查域名是否安全
    checkDomainSecurity(domain) {
        const securityIssues = []
        
        // 检查是否是可疑域名
        if (this.suspiciousDomains.includes(domain)) {
            securityIssues.push({
                type: 'SUSPICIOUS_DOMAIN',
                severity: 'CRITICAL',
                message: `检测到可疑域名: ${domain}`,
                risk: '可能是钓鱼网站或拼写错误',
                action: '立即停止使用，验证正确域名'
            })
        }
        
        // 检查是否使用HTTPS
        if (!domain.includes('https://') && !domain.includes('wss://')) {
            securityIssues.push({
                type: 'INSECURE_PROTOCOL',
                severity: 'HIGH',
                message: `域名未使用安全协议: ${domain}`,
                risk: '数据传输可能被窃听',
                action: '强制使用HTTPS/WSS协议'
            })
        }
        
        return securityIssues
    }
    
    // 🔴 验证域名证书
    async validateDomainCertificate(domain) {
        try {
            const response = await fetch(`https://${domain}`, {
                method: 'HEAD',
                timeout: 5000
            })
            
            const securityHeaders = [
                'strict-transport-security',
                'x-content-type-options',
                'x-frame-options',
                'x-xss-protection'
            ]
            
            const missingHeaders = securityHeaders.filter(header => 
                !response.headers.get(header)
            )
            
            if (missingHeaders.length > 0) {
                return {
                    valid: false,
                    issues: missingHeaders.map(header => ({
                        type: 'MISSING_SECURITY_HEADER',
                        header,
                        severity: 'MEDIUM'
                    }))
                }
            }
            
            return { valid: true, issues: [] }
            
        } catch (error) {
            return {
                valid: false,
                issues: [{
                    type: 'CERTIFICATE_ERROR',
                    error: error.message,
                    severity: 'HIGH'
                }]
            }
        }
    }
}
```

### 8. 🔧 API调用安全规则
```javascript
// 🔴 API调用安全验证 - 预防API调用错误导致的安全问题
class APISecurityValidator {
    constructor() {
        this.secureAPIs = {
            'authAPI': {
                methods: ['verifyToken', 'login', 'refresh', 'logout'],
                requiresAuth: true,
                sensitive: true
            },
            'userAPI': {
                methods: ['getUserInfo', 'updateUserInfo', 'getPointsRecords'],
                requiresAuth: true,
                sensitive: true
            },
            'lotteryAPI': {
                methods: ['getConfig', 'draw', 'getRecords'],
                requiresAuth: true,
                sensitive: false
            }
        }
        
        this.dangerousCallPatterns = [
            'userAPI.verifyToken',    // 错误的API调用
            'eval(',                  // 代码注入风险
            'innerHTML =',            // XSS风险
            'document.write('         // XSS风险
        ]
    }
    
    // 🔴 检查API调用是否安全
    checkAPICallSecurity(apiObject, method, context) {
        const securityIssues = []
        
        // 检查是否是危险的调用模式
        const callPattern = `${apiObject}.${method}`
        if (this.dangerousCallPatterns.includes(callPattern)) {
            securityIssues.push({
                type: 'DANGEROUS_API_CALL',
                severity: 'HIGH',
                message: `危险的API调用: ${callPattern}`,
                risk: 'API调用错误，可能导致功能失效',
                action: '检查API对象和方法是否正确'
            })
        }
        
        // 检查是否需要认证
        const apiConfig = this.secureAPIs[apiObject]
        if (apiConfig && apiConfig.requiresAuth) {
            if (!context.hasAuthHeader) {
                securityIssues.push({
                    type: 'MISSING_AUTH_HEADER',
                    severity: 'CRITICAL',
                    message: `敏感API调用缺少认证: ${callPattern}`,
                    risk: '未认证的API调用可能被拒绝',
                    action: '确保请求包含Authorization头'
                })
            }
        }
        
        // 检查是否是敏感数据操作
        if (apiConfig && apiConfig.sensitive) {
            if (!context.useHTTPS) {
                securityIssues.push({
                    type: 'INSECURE_SENSITIVE_DATA',
                    severity: 'HIGH',
                    message: `敏感数据未使用HTTPS传输: ${callPattern}`,
                    risk: '敏感数据可能被窃听',
                    action: '强制使用HTTPS传输敏感数据'
                })
            }
        }
        
        return securityIssues
    }
    
    // 🔴 生成安全调用建议
    generateSecureCallSuggestion(apiObject, method) {
        const apiConfig = this.secureAPIs[apiObject]
        
        if (!apiConfig) {
            return {
                message: `未知的API对象: ${apiObject}`,
                suggestion: '请检查API对象是否正确导入'
            }
        }
        
        if (!apiConfig.methods.includes(method)) {
            return {
                message: `${apiObject}不包含${method}方法`,
                suggestion: `可用方法: ${apiConfig.methods.join(', ')}`,
                possibleCorrection: this.findPossibleCorrection(method)
            }
        }
        
        return {
            message: `${apiObject}.${method}()调用正确`,
            securityRequirements: {
                requiresAuth: apiConfig.requiresAuth,
                sensitive: apiConfig.sensitive,
                useHTTPS: apiConfig.requiresAuth || apiConfig.sensitive
            }
        }
    }
}
```

### 9. 🔄 批量操作安全规则
```javascript
// 🔴 批量操作安全检查 - 预防批量操作导致的安全问题
class BatchOperationSecurity {
    constructor() {
        this.maxBatchSize = 10        // 最大批量操作数量
        this.maxConcurrency = 5       // 最大并发数
        this.operationTimeout = 30000 // 操作超时时间
        
        this.sensitiveOperations = [
            'domain_config_change',
            'api_path_modification',
            'security_header_update',
            'authentication_change'
        ]
    }
    
    // 🔴 检查批量操作是否安全
    checkBatchOperationSecurity(operation) {
        const securityIssues = []
        
        // 检查批量大小
        if (operation.batchSize > this.maxBatchSize) {
            securityIssues.push({
                type: 'EXCESSIVE_BATCH_SIZE',
                severity: 'MEDIUM',
                message: `批量操作过大: ${operation.batchSize} > ${this.maxBatchSize}`,
                risk: '可能导致系统过载或操作失败',
                action: '分批处理，每批不超过10个操作'
            })
        }
        
        // 检查并发数
        if (operation.concurrency > this.maxConcurrency) {
            securityIssues.push({
                type: 'EXCESSIVE_CONCURRENCY',
                severity: 'MEDIUM',
                message: `并发数过高: ${operation.concurrency} > ${this.maxConcurrency}`,
                risk: '可能导致系统资源耗尽',
                action: '限制并发数，避免系统过载'
            })
        }
        
        // 检查是否是敏感操作
        if (this.sensitiveOperations.includes(operation.type)) {
            securityIssues.push({
                type: 'SENSITIVE_BATCH_OPERATION',
                severity: 'HIGH',
                message: `敏感批量操作: ${operation.type}`,
                risk: '批量修改敏感配置可能导致系统故障',
                action: '逐个验证每个操作，确保正确性'
            })
        }
        
        return securityIssues
    }
    
    // 🔴 生成安全批处理计划
    generateSecureBatchPlan(operations) {
        const plan = {
            operations: [],
            phases: [],
            safeguards: []
        }
        
        // 按敏感程度分组
        const sensitiveOps = operations.filter(op => 
            this.sensitiveOperations.includes(op.type)
        )
        const normalOps = operations.filter(op => 
            !this.sensitiveOperations.includes(op.type)
        )
        
        // 敏感操作串行处理
        if (sensitiveOps.length > 0) {
            plan.phases.push({
                type: 'SENSITIVE_SEQUENTIAL',
                operations: sensitiveOps,
                concurrency: 1,
                validation: 'MANUAL'
            })
        }
        
        // 普通操作并行处理
        if (normalOps.length > 0) {
            const batches = this.splitIntoBatches(normalOps, this.maxBatchSize)
            batches.forEach((batch, index) => {
                plan.phases.push({
                    type: 'NORMAL_PARALLEL',
                    operations: batch,
                    concurrency: Math.min(batch.length, this.maxConcurrency),
                    validation: 'AUTOMATIC'
                })
            })
        }
        
        // 添加安全措施
        plan.safeguards = [
            '每个阶段完成后验证结果',
            '发现错误立即停止后续操作',
            '保留操作前状态备份',
            '提供回滚机制'
        ]
        
        return plan
    }
}
```

### 10. 📊 安全监控规则
```javascript
// 🔴 安全监控系统 - 实时监控安全问题
class SecurityMonitor {
    constructor() {
        this.securityEvents = []
        this.alertThresholds = {
            'SUSPICIOUS_DOMAIN': 1,       // 可疑域名立即告警
            'DANGEROUS_API_CALL': 1,      // 危险API调用立即告警
            'EXCESSIVE_BATCH_SIZE': 3,    // 批量操作过大3次告警
            'MISSING_AUTH_HEADER': 1      // 缺少认证头立即告警
        }
        
        this.alertCounts = new Map()
    }
    
    // 🔴 记录安全事件
    recordSecurityEvent(event) {
        const securityEvent = {
            ...event,
            timestamp: new Date().toISOString(),
            id: this.generateEventId()
        }
        
        this.securityEvents.push(securityEvent)
        
        // 检查是否需要告警
        this.checkAlertThreshold(event.type)
        
        console.log(`🔒 安全事件记录: ${event.type} - ${event.message}`)
    }
    
    // 🔴 检查告警阈值
    checkAlertThreshold(eventType) {
        const currentCount = this.alertCounts.get(eventType) || 0
        const newCount = currentCount + 1
        this.alertCounts.set(eventType, newCount)
        
        const threshold = this.alertThresholds[eventType] || 5
        
        if (newCount >= threshold) {
            this.triggerSecurityAlert(eventType, newCount)
        }
    }
    
    // 🔴 触发安全告警
    triggerSecurityAlert(eventType, count) {
        const alert = {
            type: 'SECURITY_ALERT',
            eventType,
            count,
            timestamp: new Date().toISOString(),
            severity: this.getAlertSeverity(eventType),
            message: `安全告警: ${eventType} 发生${count}次`,
            recommendedAction: this.getRecommendedAction(eventType)
        }
        
        console.error(`🚨 安全告警: ${alert.message}`)
        console.error(`🔧 建议行动: ${alert.recommendedAction}`)
        
        // 严重告警时停止操作
        if (alert.severity === 'CRITICAL') {
            console.error('🛑 检测到严重安全问题，建议立即停止操作！')
            
            return {
                stopOperation: true,
                alert
            }
        }
        
        return {
            stopOperation: false,
            alert
        }
    }
    
    // 🔴 生成安全报告
    generateSecurityReport() {
        const report = {
            reportTime: new Date().toISOString(),
            totalEvents: this.securityEvents.length,
            eventsByType: this.groupEventsByType(),
            alertHistory: Array.from(this.alertCounts.entries()),
            recommendations: this.generateSecurityRecommendations()
        }
        
        return report
    }
    
    // 🔴 生成安全建议
    generateSecurityRecommendations() {
        const recommendations = []
        
        // 基于事件类型生成建议
        const eventTypes = this.groupEventsByType()
        
        for (const [eventType, events] of Object.entries(eventTypes)) {
            if (events.length > 0) {
                switch (eventType) {
                    case 'SUSPICIOUS_DOMAIN':
                        recommendations.push({
                            type: 'DOMAIN_SECURITY',
                            priority: 'HIGH',
                            message: '检测到可疑域名使用',
                            action: '立即验证所有域名配置的正确性和安全性'
                        })
                        break
                        
                    case 'DANGEROUS_API_CALL':
                        recommendations.push({
                            type: 'API_SECURITY',
                            priority: 'HIGH',
                            message: '检测到危险API调用',
                            action: '审查所有API调用，确保使用正确的方法'
                        })
                        break
                        
                    case 'EXCESSIVE_BATCH_SIZE':
                        recommendations.push({
                            type: 'BATCH_SECURITY',
                            priority: 'MEDIUM',
                            message: '检测到过大批量操作',
                            action: '优化批量操作策略，分批处理大量数据'
                        })
                        break
                }
            }
        }
        
        return recommendations
    }
}
```

---

**新增安全规则创建时间**: 2025年01月03日  
**基于安全事件**: 域名配置错误、API调用错误等安全问题  
**安全等级**: 高级安全规则，违反时立即停止操作  
**适用范围**: 所有涉及域名、API、批量操作的开发会话  
**维护责任**: 核心开发团队，定期审查和更新
```





