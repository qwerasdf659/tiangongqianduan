---
description: 
globs: 
alwaysApply: true
---
# ğŸ” å¤©å·¥é¡¹ç›®å®‰å…¨ä¸è´¨é‡æ ‡å‡†è§„èŒƒ

## ğŸš¨ æ ¸å¿ƒå®‰å…¨åŸåˆ™ - è¿ååˆ™ç«‹å³åœæ­¢å¼€å‘

### 1. ğŸ” æ•°æ®å®‰å…¨æ ¸å¿ƒè§„åˆ™ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰

#### ç»å¯¹ç¦æ­¢å‰ç«¯ç¡¬ç¼–ç æ•æ„Ÿä¸šåŠ¡æ•°æ®
```javascript
// âŒ ä¸¥ç¦ï¼šå‰ç«¯ç¡¬ç¼–ç å¥–å“é…ç½®
const PRIZES = [
  { name: 'å¥–å“1', probability: 10 },
  { name: 'å¥–å“2', probability: 20 }
]

// âŒ ä¸¥ç¦ï¼šå‰ç«¯ç¡¬ç¼–ç å•†å“ä»·æ ¼
const PRODUCTS = [
  { id: 1, name: 'å•†å“1', price: 100 }
]

// âŒ ä¸¥ç¦ï¼šå‰ç«¯è®¡ç®—ä¸šåŠ¡é€»è¾‘
const probability = Math.random() * 100
const userPermission = user.role === 'admin'
```

#### ç»å¯¹ç¦æ­¢ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®æ›¿ä»£åç«¯API
```javascript
// âŒ ä¸¥ç¦ï¼šMockæ•°æ®å‡½æ•°
const mockRequest = () => { /* å‡æ•°æ® */ }
const shouldUseMock = () => true
const smartApiCall = (real, mock) => mock

// âŒ ä¸¥ç¦ï¼šsetTimeoutæ¨¡æ‹Ÿå¼‚æ­¥
setTimeout(() => {
  callback({ data: mockData })
}, 1000)
```

#### å¼ºåˆ¶åç«¯ä¾èµ–æ£€æŸ¥ä¸é”™è¯¯å¤„ç†
```javascript
// âœ… æ­£ç¡®ï¼šçœŸå®APIè°ƒç”¨ + å®Œæ•´é”™è¯¯å¤„ç†
api.getData().then(result => {
  if (result.code === 0) {
    // ä½¿ç”¨åç«¯æ•°æ®ï¼Œæ·»åŠ è¯¦ç»†æ³¨é‡Šè¯´æ˜æ•°æ®ç”¨é€”
    this.setData({ data: result.data })
  } else {
    throw new Error('âš ï¸ åç«¯æœåŠ¡å¼‚å¸¸ï¼š' + result.msg)
  }
}).catch(error => {
  // å¢å¼ºé”™è¯¯å¤„ç†ï¼šæä¾›æ˜ç¡®çš„é”™è¯¯ä¿¡æ¯å’Œè§£å†³å»ºè®®
  wx.showModal({
    title: 'ğŸš¨ åç«¯æœåŠ¡é—®é¢˜',
    content: `æ— æ³•è·å–æ•°æ®ï¼\n\nå¯èƒ½åŸå› ï¼š\n1. åç«¯APIæœåŠ¡æœªå¯åŠ¨\n2. æ¥å£å¼‚å¸¸\n3. æ•°æ®åº“è¿æ¥é—®é¢˜\n\nè¯·ç«‹å³æ£€æŸ¥åç«¯æœåŠ¡çŠ¶æ€ï¼`
  })
})
```

### 2. ğŸ› ï¸ æ–¹æ³•è°ƒç”¨å®‰å…¨è§„èŒƒ

#### å¯¼å…¥å‡½æ•°è°ƒç”¨é”™è¯¯é˜²æŠ¤
```javascript
// âŒ ç¦æ­¢ï¼šå°†å¯¼å…¥å‡½æ•°å½“ä½œå¯¹è±¡æ–¹æ³•è°ƒç”¨
const { getTechnicalConfig } = require('./config')
// é”™è¯¯è°ƒç”¨
this.getTechnicalConfig()  // TypeError: this.getTechnicalConfig is not a function

// âœ… æ­£ç¡®ï¼šç›´æ¥è°ƒç”¨å¯¼å…¥å‡½æ•°ï¼Œæ·»åŠ è¯¦ç»†æ³¨é‡Š
// è·å–æŠ€æœ¯é…ç½®ä¿¡æ¯ï¼Œç”¨äºåˆå§‹åŒ–ç³»ç»Ÿå‚æ•°
const config = getTechnicalConfig()

// éªŒè¯ç”¨æˆ·è¾“å…¥è¡¨å•æ•°æ®çš„å®Œæ•´æ€§å’Œæ ¼å¼
const isValid = validateForm(formData)

// æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºå¯è¯»çš„æ—¥æœŸæ ¼å¼
const displayDate = formatDate(timestamp)
```

#### æ¨¡å—å¯¼å…¥ä¸€è‡´æ€§æ£€æŸ¥
```javascript
// âœ… ç»Ÿä¸€å¯¼å…¥è·¯å¾„å’Œé”™è¯¯å¤„ç†
const { validateForm } = require('../../utils/validate')
const { formatDate } = require('../../utils/util')

// å¼ºåˆ¶æ•°æ®å­˜åœ¨æ€§æ£€æŸ¥ï¼šæ‰€æœ‰æŸ¥è¯¢å‰å¿…é¡»éªŒè¯æ•°æ®æ˜¯å¦å­˜åœ¨
if (!app.globalData) {
  console.error('ğŸš¨ å…¨å±€æ•°æ®æœªåˆå§‹åŒ–')
  return
}

if (!app.globalData.userInfo) {
  // è·³è½¬åˆ°ç™»å½•é¡µé¢æˆ–æ˜¾ç¤ºç™»å½•æç¤º
  wx.navigateTo({ url: '/pages/auth/auth' })
  return
}
```

### 3. ğŸ”’ å¯¹è±¡å±æ€§å®‰å…¨è®¿é—®è§„èŒƒ

#### æ·±å±‚å±æ€§è®¿é—®é˜²æŠ¤
```javascript
// âŒ ç¦æ­¢ï¼šä¸å®‰å…¨çš„å±æ€§è®¿é—®
app.globalData.config.isDev  // å¯èƒ½ä¸ºundefined
user.profile.avatar.url      // å¤šå±‚çº§è®¿é—®é£é™©

// âœ… æ­£ç¡®ï¼šæä¾›åå¤‡å€¼å’Œå®‰å…¨æ£€æŸ¥
const config = app.globalData.config || app.globalData || { isDev: true }
const isDev = config.isDev || false

const avatarUrl = user?.profile?.avatar?.url || '/images/default-avatar.png'

// âœ… æ·±åº¦æ€è€ƒé¡¹ç›®ä»£ç é€»è¾‘ï¼Œç¡®ä¿æ•°æ®å®‰å…¨è®¿é—®
const userInfo = app.globalData.userInfo
if (userInfo && userInfo.profile) {
  const avatar = userInfo.profile.avatar || '/images/default-avatar.png'
  // å®‰å…¨ä½¿ç”¨ç”¨æˆ·å¤´åƒæ•°æ®
}
```

### 4. ğŸ¨ å¾®ä¿¡å°ç¨‹åºAPIå…¼å®¹æ€§æ£€æŸ¥ç³»ç»Ÿ

#### Canvas APIå…¼å®¹æ€§åŒé‡æ£€æŸ¥
```javascript
// âœ… ç»Ÿä¸€å…¼å®¹æ€§æ£€æŸ¥å·¥å…· (utils/compatibility-check.js)
const checkCanvasAPI = (ctx) => {
  return {
    createLinearGradient: typeof ctx.createLinearGradient === 'function',
    createRadialGradient: typeof ctx.createRadialGradient === 'function',
    quadraticCurveTo: typeof ctx.quadraticCurveTo === 'function',
    bezierCurveTo: typeof ctx.bezierCurveTo === 'function',
    setLineDash: typeof ctx.setLineDash === 'function',
    filter: 'filter' in ctx
  }
}

// âœ… æ³¨æ„ç¼–å†™çš„ä»£ç ç¬¦åˆå¾®ä¿¡å°ç¨‹åºå¼€å‘æ ‡å‡†ï¼Œè€ƒè™‘APIå…¼å®¹æ€§
if (compatibility.createLinearGradient && typeof ctx.createLinearGradient === 'function') {
  try {
    const gradient = ctx.createLinearGradient(0, 0, 100, 0)
    gradient.addColorStop(0, '#ff0000')
    gradient.addColorStop(1, '#00ff00')
    ctx.fillStyle = gradient
  } catch (error) {
    console.warn('çº¿æ€§æ¸å˜ä¸æ”¯æŒï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ:', error)
    ctx.fillStyle = '#ff0000'  // é™çº§ä¸ºçº¯è‰²
  }
} else {
  ctx.fillStyle = '#ff0000'  // ç›´æ¥ä½¿ç”¨é™çº§æ–¹æ¡ˆ
}
```

#### æ™ºèƒ½é™çº§ç­–ç•¥
```javascript
// âœ… æ ¹æ®å…¼å®¹æ€§æ£€æŸ¥ç»“æœæ™ºèƒ½é€‰æ‹©ç­–ç•¥
const drawWithCompatibility = (ctx, compatibility) => {
  if (compatibility.createRadialGradient && compatibility.quadraticCurveTo) {
    // é«˜çº§ç»˜åˆ¶ï¼šæ¸å˜ + æ›²çº¿ï¼Œè§†è§‰ç¾æ„Ÿ 95%+
    drawAdvancedStyle(ctx)
  } else if (compatibility.createLinearGradient) {
    // ä¸­çº§ç»˜åˆ¶ï¼šçº¿æ€§æ¸å˜ï¼Œè§†è§‰ç¾æ„Ÿ 80%+
    drawMediumStyle(ctx)
  } else {
    // åŸºç¡€ç»˜åˆ¶ï¼šçº¯è‰²å¡«å……ï¼Œè§†è§‰ç¾æ„Ÿ 60%+ï¼Œç¡®ä¿100%å…¼å®¹æ€§
    drawBasicStyle(ctx)
  }
}
```

### 5. ğŸš€ ä¸‰å±‚é”™è¯¯å¤„ç†ä¸æ™ºèƒ½é™çº§æœºåˆ¶

#### å®Œæ•´é”™è¯¯å¤„ç†æ¨¡å¼
```javascript
// âœ… ç¬¬ä¸€å±‚ï¼šåŠŸèƒ½æ£€æŸ¥
if (!compatibility.targetAPI) {
  console.warn('APIä¸æ”¯æŒï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ')
  return fallbackMethod()
}

// âœ… ç¬¬äºŒå±‚ï¼šç±»å‹æ£€æŸ¥
if (typeof ctx.targetAPI !== 'function') {
  console.warn('APIç±»å‹å¼‚å¸¸ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ')
  return fallbackMethod()
}

// âœ… ç¬¬ä¸‰å±‚ï¼šè¿è¡Œæ—¶é”™è¯¯æ•è·
try {
  return ctx.targetAPI(...args)
} catch (error) {
  console.error('APIè°ƒç”¨å¤±è´¥:', error)
  return fallbackMethod()
}
```

#### å¢å¼ºé”™è¯¯å¤„ç†ä¸è§£å†³å»ºè®®
```javascript
// âœ… æä¾›æ˜ç¡®çš„é”™è¯¯ä¿¡æ¯å’Œè§£å†³å»ºè®®
const handleError = (error, context) => {
  const errorMap = {
    'TypeError': 'ç±»å‹é”™è¯¯ - è¯·æ£€æŸ¥å˜é‡ç±»å‹å’Œæ–¹æ³•è°ƒç”¨',
    'ReferenceError': 'å¼•ç”¨é”™è¯¯ - è¯·æ£€æŸ¥å˜é‡æ˜¯å¦å·²å®šä¹‰',
    'Canvas API Error': 'Canvas APIä¸å…¼å®¹ - å·²å¯ç”¨é™çº§æ–¹æ¡ˆ'
  }
  
  const errorType = error.name || 'Unknown'
  const suggestion = errorMap[errorType] || 'è¯·æ£€æŸ¥ä»£ç é€»è¾‘å’Œç¯å¢ƒå…¼å®¹æ€§'
  
  console.error(`ğŸš¨ ${context}å‘ç”Ÿé”™è¯¯:`, error)
  console.warn(`ğŸ’¡ å»ºè®®è§£å†³æ–¹æ¡ˆ: ${suggestion}`)
  
  // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
  wx.showToast({
    title: 'åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨',
    icon: 'none',
    duration: 2000
  })
}
```

### 6. ğŸ“ ä»£ç æ³¨é‡Šä¸æ–‡æ¡£è§„èŒƒ

#### è¯¦ç»†ä»£ç æ³¨é‡Šæ ‡å‡†
```javascript
// âœ… ä»£ç è¦æœ‰è¯¦ç»†æ³¨é‡Š - ä¸ºæ‰€æœ‰å‡½æ•°è°ƒç”¨æ·»åŠ è¯¦ç»†æ³¨é‡Š
// ğŸ”´ å¿…é¡»ä»åç«¯è·å–ï¼Œä¸¥ç¦å‰ç«¯ç¡¬ç¼–ç 
// ğŸš¨ æ ¸å¿ƒå®‰å…¨æ•°æ®ï¼Œä¸å…è®¸å‰ç«¯æ¨¡æ‹Ÿ
// âš ï¸ åç«¯æœåŠ¡å¼‚å¸¸æ—¶çš„é”™è¯¯å¤„ç†
// âœ… æ­£ç¡®çš„åç«¯APIè°ƒç”¨æ–¹å¼

// è·å–æŠ½å¥–é…ç½®ä¿¡æ¯ï¼ŒåŒ…å«å¥–å“åˆ—è¡¨å’Œæ¶ˆè€—ç§¯åˆ†
lotteryAPI.getConfig().then(result => {
  if (result.code === 0) {
    // è®¾ç½®æŠ½å¥–å¥–å“æ•°æ®åˆ°é¡µé¢çŠ¶æ€ä¸­
    this.setData({ 
      prizes: result.data.prizes,        // å¥–å“åˆ—è¡¨
      costPoints: result.data.cost_points // æŠ½å¥–æ¶ˆè€—ç§¯åˆ†
    })
  } else {
    throw new Error('è·å–æŠ½å¥–é…ç½®å¤±è´¥')
  }
}).catch(error => {
  wx.showModal({
    title: 'âš ï¸ åç«¯æœåŠ¡å¼‚å¸¸', 
    content: 'æ— æ³•è·å–æŠ½å¥–é…ç½®ï¼è¯·æ£€æŸ¥åç«¯APIæœåŠ¡ã€‚'
  })
})
```

#### ç»Ÿä¸€æµ‹è¯•æ•°æ®ç®¡ç†é…ç½®
```javascript
// âœ… ç»Ÿä¸€æµ‹è¯•æ•°æ®ç®¡ç† - å¼€å‘é˜¶æ®µä½¿ç”¨
const initTestData = () => {
  // ä¸åç«¯APIæ•°æ®ç»“æ„ä¿æŒä¸€è‡´çš„æµ‹è¯•æ•°æ®
  // æ³¨æ„ï¼šä»…ç”¨äºç»“æ„å‚è€ƒï¼Œä¸èƒ½æ›¿ä»£çœŸå®APIè°ƒç”¨
  return {
    prizes: [],           // ç»“æ„å ä½ï¼Œå®é™…æ•°æ®æ¥è‡ªåç«¯
    costPoints: 0,        // ç»“æ„å ä½ï¼Œå®é™…æ•°æ®æ¥è‡ªåç«¯
    userPoints: 0         // ç»“æ„å ä½ï¼Œå®é™…æ•°æ®æ¥è‡ªåç«¯
  }
}

// âœ… æµ‹è¯•æ•°æ®åŒæ­¥æœºåˆ¶ï¼šä¿®æ”¹åˆå§‹åŒ–è„šæœ¬æ—¶åŒæ­¥æ›´æ–°æµ‹è¯•è„šæœ¬
const testConfig = {
  dataStructure: 'consistent_with_backend',
  syncMechanism: 'auto_update',
  errorHandling: 'comprehensive'
}
```

### 7. ğŸ” è¿è§„ä»£ç è‡ªåŠ¨æ£€æµ‹è§„åˆ™

#### å¿…é¡»æ‹’ç»çš„å±é™©ä»£ç æ¨¡å¼
```regex
# æ£€æŸ¥æ–¹æ³•è°ƒç”¨é”™è¯¯
this\.[a-zA-Z]+Config\(\)
this\.[a-zA-Z]+Util\(\)
this\.[a-zA-Z]+API\(\)

# æ£€æŸ¥ä¸å®‰å…¨å±æ€§è®¿é—®
globalData\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))
app\.[a-zA-Z]+\.[a-zA-Z]+\.[a-zA-Z]+(?!\s*(\|\||&&|\?\.))

# æ£€æŸ¥Canvas APIè°ƒç”¨ç¼ºå°‘å…¼å®¹æ€§æ£€æŸ¥
(createLinearGradient|createRadialGradient|quadraticCurveTo)(?!.*typeof)(?!.*compatibility)

# æ£€æŸ¥ç¡¬ç¼–ç æ•°æ®
(const|let|var)\s+(PRIZES|PRODUCTS|CONFIG)\s*=\s*\[
(const|let|var)\s+\w+\s*=\s*\[.*probability.*\]

# æ£€æŸ¥Mockæ ‡è¯†
(mock|fake|test|demo)(Data|Request|Api|Function)
setTimeout\(\s*\(\)\s*=>\s*{.*callback.*mockData.*}

# æ£€æŸ¥å‰ç«¯ä¸šåŠ¡é€»è¾‘è®¡ç®—
Math\.random\(\)\s*\*\s*\d+
user\.(role|type)\s*===\s*['"]
```

#### å¿…é¡»é€šè¿‡çš„å®‰å…¨ä»£ç æ¨¡å¼
- [ ] å¯¼å…¥å‡½æ•°ç›´æ¥è°ƒç”¨ï¼š`å‡½æ•°å()`ï¼Œä¸ä½¿ç”¨`this.å‡½æ•°å()`
- [ ] å®‰å…¨å±æ€§è®¿é—®ï¼š`obj?.prop || defaultValue` æˆ– `obj.prop || defaultValue`
- [ ] åŒé‡APIæ£€æŸ¥ï¼š`if (compatibility.api && typeof ctx.api === 'function')`
- [ ] å®Œæ•´é”™è¯¯å¤„ç†ï¼š`try-catch` + é™çº§æ–¹æ¡ˆ
- [ ] æ•°æ®å­˜åœ¨æ€§éªŒè¯ï¼šè°ƒç”¨å‰æ£€æŸ¥å¯¹è±¡æ˜¯å¦å­˜åœ¨
- [ ] è¯¦ç»†ä»£ç æ³¨é‡Šï¼šè¯´æ˜å‡½æ•°ç”¨é€”å’Œå‚æ•°å«ä¹‰
- [ ] æ‰€æœ‰ä¸šåŠ¡æ•°æ®æ¥æºäºåç«¯API
- [ ] åŒ…å«å®Œæ•´çš„åç«¯å¼‚å¸¸å¤„ç†æœºåˆ¶

### 8. ğŸ¯ é¡¹ç›®è¿è¡ŒçŠ¶æ€æ£€æŸ¥æœºåˆ¶

#### å®Œæˆä»»åŠ¡åçš„é¡¹ç›®è¿è¡Œæ£€æŸ¥
```javascript
// âœ… å®Œæˆå…¨éƒ¨ä»»åŠ¡åæ£€æŸ¥é¡¹ç›®æ˜¯å¦å¯ä»¥æ­£å¸¸è¿è¡Œ
const checkProjectHealth = () => {
  const checks = {
    // æ£€æŸ¥æ ¸å¿ƒç»„ä»¶æ˜¯å¦æ­£å¸¸
    components: checkComponentsStatus(),
    // æ£€æŸ¥APIè¿æ¥çŠ¶æ€
    apiConnection: checkAPIStatus(),
    // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    dataIntegrity: checkDataIntegrity(),
    // æ£€æŸ¥å…¼å®¹æ€§æ”¯æŒ
    compatibility: checkCompatibility()
  }
  
  const issues = []
  Object.keys(checks).forEach(key => {
    if (!checks[key].status) {
      issues.push({
        type: key,
        error: checks[key].error,
        solution: checks[key].solution
      })
    }
  })
  
  if (issues.length > 0) {
    console.error('ğŸš¨ é¡¹ç›®è¿è¡Œæ£€æŸ¥å‘ç°é—®é¢˜:', issues)
    // å¦‚æœæœ‰é—®é¢˜å°±è¦é©¬ä¸Šä¿®å¤
    fixProjectIssues(issues)
  } else {
    console.log('âœ… é¡¹ç›®è¿è¡ŒçŠ¶æ€è‰¯å¥½')
  }
}
```

#### é—®é¢˜ç±»å‹åˆ†æä¸è§£å†³
```javascript
// âœ… é¡¹ç›®å‡ºç°é—®é¢˜è¦è€ƒè™‘ç»„ä»¶ç¼ºå¤±ã€ç»„ä»¶é”™è¯¯ã€é€»è¾‘æ–¹æ¡ˆã€ç¯å¢ƒé—®é¢˜ç­‰
const analyzeAndSolve = (error) => {
  const problemTypes = {
    'Component Missing': {
      analysis: 'æ£€æŸ¥ç»„ä»¶æ–‡ä»¶æ˜¯å¦å­˜åœ¨',
      solution: 'é‡æ–°åˆ›å»ºæˆ–ä¿®å¤ç»„ä»¶æ–‡ä»¶'
    },
    'Component Error': {
      analysis: 'ç»„ä»¶é€»è¾‘é”™è¯¯æˆ–APIè°ƒç”¨é—®é¢˜',
      solution: 'æ£€æŸ¥ç»„ä»¶ä»£ç å’ŒAPIè°ƒç”¨'
    },
    'Logic Error': {
      analysis: 'ä¸šåŠ¡é€»è¾‘æ–¹æ¡ˆä¸æ­£ç¡®',
      solution: 'é‡æ–°è®¾è®¡ä¸šåŠ¡é€»è¾‘æµç¨‹'
    },
    'Environment Issue': {
      analysis: 'å¼€å‘ç¯å¢ƒé…ç½®é—®é¢˜',
      solution: 'æ£€æŸ¥å¾®ä¿¡å¼€å‘è€…å·¥å…·é…ç½®'
    }
  }
  
  return problemTypes[error.type] || {
    analysis: 'æœªçŸ¥é—®é¢˜ç±»å‹',
    solution: 'è¯·è¿›è¡Œå…¨é¢çš„ä»£ç å®¡æŸ¥'
  }
}
```

### 9. ğŸ§¹ ä»£ç æ¸…ç†ä¸æ–‡ä»¶ç®¡ç†

#### è‡ªåŠ¨æ¸…ç†ä¸´æ—¶æ–‡ä»¶è§„åˆ™
```javascript
// âœ… æ¯æ¬¡å®Œæˆä»»åŠ¡ååˆ›å»ºçš„ä¸´æ—¶æ–‡ä»¶ã€æµ‹è¯•æ–‡ä»¶éƒ½è¦è‡ªè¡Œåˆ é™¤
const cleanupTemporaryFiles = () => {
  const tempPatterns = [
    '**/*.temp.js',
    '**/*.test.tmp',
    '**/temp_*',
    '**/*.backup',
    '**/*.log',
    '**/*unused*.md'  // æ²¡ç”¨ã€é‡å¤çš„æ–‡ä»¶å’Œæ— ç”¨çš„mdæ–‡ä»¶éƒ½è¦è‡ªè¡Œåˆ é™¤
  ]
  
  tempPatterns.forEach(pattern => {
    console.log(`ğŸ§¹ æ¸…ç†ä¸´æ—¶æ–‡ä»¶: ${pattern}`)
  })
  
  // åˆ é™¤æ— ç”¨çš„é‡å¤æ–‡ä»¶å’Œæ— ç”¨çš„mdæ–‡ä»¶
  cleanupDuplicateFiles()
  cleanupUnusedMarkdownFiles()
}
```

### 10. ğŸš€ å·¥å…·è°ƒç”¨æ•ˆç‡ä¼˜åŒ–è§„åˆ™ (æ–°å¢CRITICAL - é˜²æ­¢æµªè´¹Claude 4 Sonnetè¯·æ±‚)

#### å¼ºåˆ¶å¹¶è¡Œå·¥å…·è°ƒç”¨è§„åˆ™
```javascript
// ğŸ”´ å¼ºåˆ¶è¦æ±‚ï¼šä¿¡æ¯æ”¶é›†é˜¶æ®µå¿…é¡»å¹¶è¡Œæ‰§è¡Œï¼Œè¿ååˆ™è­¦å‘Š
class ParallelToolManager {
    constructor() {
        this.callLog = []
        this.efficiency = {
            parallelCalls: 0,
            serialCalls: 0,
            wastedRequests: 0
        }
    }
    
    // ğŸ”´ æ£€æµ‹ä¸²è¡Œè°ƒç”¨æµªè´¹
    detectSerialWaste(toolCalls) {
        const canBeParallel = [
            'read_file', 'grep_search', 'run_terminal_cmd', 
            'codebase_search', 'list_dir', 'file_search'
        ]
        
        let consecutiveSerialCalls = 0
        let wastedCalls = 0
        
        for (let i = 0; i < toolCalls.length - 1; i++) {
            const current = toolCalls[i]
            const next = toolCalls[i + 1]
            
            if (canBeParallel.includes(current.name) && 
                canBeParallel.includes(next.name)) {
                consecutiveSerialCalls++
                if (consecutiveSerialCalls >= 2) {
                    wastedCalls++
                }
            } else {
                consecutiveSerialCalls = 0
            }
        }
        
        this.efficiency.wastedRequests += wastedCalls
        
        if (wastedCalls > 0) {
            console.warn(`âš ï¸ æ£€æµ‹åˆ°${wastedCalls}ä¸ªå¯å¹¶è¡Œçš„ä¸²è¡Œè°ƒç”¨ï¼Œæµªè´¹Claude 4 Sonnetè¯·æ±‚æ¬¡æ•°`)
            return wastedCalls
        }
        
        return 0
    }
    
    // ğŸ”´ æ¨èå¹¶è¡Œæ‰§è¡Œæ–¹æ¡ˆ
    suggestParallelExecution(toolCalls) {
        const parallelGroups = []
        let currentGroup = []
        
        const canBeParallel = [
            'read_file', 'grep_search', 'run_terminal_cmd', 
            'codebase_search', 'list_dir', 'file_search'
        ]
        
        for (const call of toolCalls) {
            if (canBeParallel.includes(call.name)) {
                currentGroup.push(call)
            } else {
                if (currentGroup.length > 0) {
                    parallelGroups.push([...currentGroup])
                    currentGroup = []
                }
                parallelGroups.push([call])
            }
        }
        
        if (currentGroup.length > 0) {
            parallelGroups.push(currentGroup)
        }
        
        return parallelGroups
    }
    
    // ğŸ”´ ç”Ÿæˆå¹¶è¡Œæ‰§è¡Œä»£ç 
    generateParallelCode(toolCalls) {
        const parallelGroups = this.suggestParallelExecution(toolCalls)
        let code = '// ğŸ”´ æ¨èçš„å¹¶è¡Œæ‰§è¡Œæ–¹æ¡ˆ:\n'
        
        for (let i = 0; i < parallelGroups.length; i++) {
            const group = parallelGroups[i]
            
            if (group.length === 1) {
                code += `const result${i} = await ${group[0].name}(${JSON.stringify(group[0].params)})\n`
            } else {
                code += `const [${group.map((_, idx) => `result${i}_${idx}`).join(', ')}] = await Promise.all([\n`
                for (const call of group) {
                    code += `    ${call.name}(${JSON.stringify(call.params)}),\n`
                }
                code += '])\n'
            }
        }
        
        return code
    }
}

// ğŸ”´ å…¨å±€å¹¶è¡Œå·¥å…·ç®¡ç†å™¨
const parallelManager = new ParallelToolManager()

// ğŸ”´ å¼ºåˆ¶ä½¿ç”¨æ–¹å¼ç¤ºä¾‹
const efficientToolExecution = async () => {
    // âŒ é”™è¯¯ï¼šä¸²è¡Œæ‰§è¡Œæµªè´¹è¯·æ±‚æ¬¡æ•°
    // const file1 = await read_file('file1.js')
    // const file2 = await read_file('file2.js')
    // const cmdResult = await run_terminal_cmd('Get-ChildItem')
    
    // âœ… æ­£ç¡®ï¼šå¹¶è¡Œæ‰§è¡ŒèŠ‚çœ50-80%æ—¶é—´
    const [file1, file2, cmdResult] = await Promise.all([
        read_file('file1.js'),
        read_file('file2.js'),
        run_terminal_cmd('Get-ChildItem')
    ])
    
    parallelManager.efficiency.parallelCalls += 3
    return { file1, file2, cmdResult }
}
```

#### search_replaceå·¥å…·ç²¾ç¡®åŒ¹é…æ”¹è¿›è§„åˆ™
```javascript
// ğŸ”´ search_replaceå·¥å…·å®‰å…¨ä½¿ç”¨è§„åˆ™
class SearchReplaceValidator {
    constructor() {
        this.minContextLines = 3
        this.maxAttempts = 3
    }
    
    // ğŸ”´ éªŒè¯åŒ¹é…å­—ç¬¦ä¸²å‡†ç¡®æ€§
    validateMatchString(oldString, filePath) {
        const warnings = []
        
        // æ£€æŸ¥ä¸Šä¸‹æ–‡è¡Œæ•°
        const lines = oldString.split('\n')
        if (lines.length < this.minContextLines) {
            warnings.push(`âš ï¸ ä¸Šä¸‹æ–‡ä¸è¶³ï¼Œå»ºè®®è‡³å°‘åŒ…å«${this.minContextLines}è¡Œä¸Šä¸‹æ–‡`)
        }
        
        // æ£€æŸ¥ç‰¹æ®Šå­—ç¬¦
        const specialChars = /['"\\]/g
        if (specialChars.test(oldString)) {
            warnings.push('âš ï¸ åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œå¯èƒ½å¯¼è‡´åŒ¹é…å¤±è´¥')
        }
        
        // æ£€æŸ¥ç©ºç™½å­—ç¬¦
        if (oldString.includes('\t') || oldString.includes('    ')) {
            warnings.push('âš ï¸ åŒ…å«åˆ¶è¡¨ç¬¦æˆ–å¤šç©ºæ ¼ï¼Œæ³¨æ„ç©ºç™½å­—ç¬¦åŒ¹é…')
        }
        
        return warnings
    }
    
    // ğŸ”´ ç”Ÿæˆå®‰å…¨çš„åŒ¹é…å­—ç¬¦ä¸²
    createSafeMatchString(targetContent, startMarker, endMarker) {
        const lines = targetContent.split('\n')
        const startIndex = lines.findIndex(line => line.includes(startMarker))
        const endIndex = lines.findIndex((line, idx) => 
            idx > startIndex && line.includes(endMarker)
        )
        
        if (startIndex === -1 || endIndex === -1) {
            throw new Error('æ— æ³•æ‰¾åˆ°åŒ¹é…çš„å¼€å§‹æˆ–ç»“æŸæ ‡è®°')
        }
        
        // åŒ…å«è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡
        const contextStart = Math.max(0, startIndex - 2)
        const contextEnd = Math.min(lines.length - 1, endIndex + 2)
        
        return lines.slice(contextStart, contextEnd + 1).join('\n')
    }
    
    // ğŸ”´ è‡ªåŠ¨é‡è¯•æœºåˆ¶
    async attemptSearchReplace(filePath, oldString, newString) {
        for (let attempt = 1; attempt <= this.maxAttempts; attempt++) {
            try {
                console.log(`ğŸ”„ search_replace å°è¯• ${attempt}/${this.maxAttempts}`)
                
                const warnings = this.validateMatchString(oldString, filePath)
                if (warnings.length > 0) {
                    console.warn('search_replace è­¦å‘Š:', warnings.join('\n'))
                }
                
                return await search_replace(filePath, oldString, newString)
                
            } catch (error) {
                console.error(`âŒ search_replace ç¬¬${attempt}æ¬¡å°è¯•å¤±è´¥:`, error.message)
                
                if (attempt === this.maxAttempts) {
                    console.error('ğŸš¨ search_replace æ‰€æœ‰å°è¯•å¤±è´¥ï¼Œå»ºè®®ï¼š')
                    console.error('1. ä½¿ç”¨ read_file ç¡®è®¤æ–‡ä»¶å†…å®¹')
                    console.error('2. å¢åŠ æ›´å¤šä¸Šä¸‹æ–‡è¡Œ')
                    console.error('3. æ£€æŸ¥ç©ºç™½å­—ç¬¦å’Œç‰¹æ®Šå­—ç¬¦')
                    console.error('4. è€ƒè™‘ä½¿ç”¨ edit_file æ›¿ä»£')
                    throw error
                }
                
                // ç­‰å¾…åé‡è¯•
                await new Promise(resolve => setTimeout(resolve, 1000 * attempt))
            }
        }
    }
}

// ğŸ”´ å…¨å±€search_replaceéªŒè¯å™¨
const searchReplaceValidator = new SearchReplaceValidator()

// ğŸ”´ å®‰å…¨ä½¿ç”¨æ–¹å¼
const safeSearchReplace = async (filePath, oldString, newString) => {
    return await searchReplaceValidator.attemptSearchReplace(filePath, oldString, newString)
}
```

#### æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦å®‰å…¨å¤„ç†
```javascript
// ğŸ”´ è‡ªåŠ¨è½¬ä¹‰emojiå’Œç‰¹æ®Šå­—ç¬¦
class RegexSafetyProcessor {
    constructor() {
        this.emojiMap = {
            'ğŸ”§': '\\u{1F527}',
            'ğŸ”—': '\\u{1F517}', 
            'ğŸ“¨': '\\u{1F4E8}',
            'âŒ': '\\u{274C}',
            'âœ…': '\\u{2705}',
            'âš ï¸': '\\u{26A0}\\u{FE0F}',
            'ğŸš¨': '\\u{1F6A8}'
        }
        
        this.specialCharsPattern = /[\\^$.*+?()[\]{}|]/g
    }
    
    // ğŸ”´ è‡ªåŠ¨å¤„ç†emojiå­—ç¬¦
    escapeEmojiPattern(pattern) {
        let safePattern = pattern
        
        for (const [emoji, unicode] of Object.entries(this.emojiMap)) {
            const emojiRegex = new RegExp(
                emoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 
                'g'
            )
            safePattern = safePattern.replace(emojiRegex, unicode)
        }
        
        return safePattern
    }
    
    // ğŸ”´ è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
    escapeSpecialChars(pattern) {
        return pattern.replace(this.specialCharsPattern, '\\$&')
    }
    
    // ğŸ”´ ç»¼åˆå®‰å…¨å¤„ç†
    createSafePattern(unsafePattern) {
        console.log(`ğŸ”§ å¤„ç†ä¸å®‰å…¨çš„æ­£åˆ™è¡¨è¾¾å¼: ${unsafePattern}`)
        
        let safePattern = unsafePattern
        safePattern = this.escapeEmojiPattern(safePattern)
        safePattern = this.escapeSpecialChars(safePattern)
        
        console.log(`âœ… è½¬æ¢ä¸ºå®‰å…¨çš„æ­£åˆ™è¡¨è¾¾å¼: ${safePattern}`)
        return safePattern
    }
}

// ğŸ”´ å…¨å±€æ­£åˆ™å®‰å…¨å¤„ç†å™¨
const regexProcessor = new RegexSafetyProcessor()

// ğŸ”´ å®‰å…¨ä½¿ç”¨æ–¹å¼
const safeGrepSearch = async (unsafePattern, includePattern) => {
    const safePattern = regexProcessor.createSafePattern(unsafePattern)
    return await grep_search(safePattern, includePattern)
}
```

### 11. âš¡ å¼ºåˆ¶æ‰§è¡Œæœºåˆ¶

#### å‘ç°è¿è§„ä»£ç æ—¶å¿…é¡»æ‰§è¡Œçš„æ“ä½œ
1. **ç«‹å³åœæ­¢æ‰€æœ‰å¼€å‘å·¥ä½œ**
2. **æ˜¾ç¤ºå…·ä½“è¿è§„é¡¹å’Œè§„åˆ™ç¼–å·**
3. **æä¾›æ­£ç¡®çš„åç«¯APIè°ƒç”¨ç¤ºä¾‹**
4. **è¦æ±‚å¼€å‘è€…ç¡®è®¤åç«¯æœåŠ¡çŠ¶æ€**

#### è¿è§„é”™è¯¯æç¤ºæ¨¡æ¿
```
ğŸš¨ ä¸¥é‡è¿è§„ï¼è¿åå¤©å·¥é¡¹ç›®æ ¸å¿ƒå®‰å…¨è§„åˆ™

è¿è§„ç±»å‹ï¼š[å‰ç«¯ç¡¬ç¼–ç æ•æ„Ÿæ•°æ®/ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®/æ–¹æ³•è°ƒç”¨é”™è¯¯/ä¸å®‰å…¨å±æ€§è®¿é—®]
è¿è§„ä½ç½®ï¼šæ–‡ä»¶å:è¡Œå·
è¿è§„å†…å®¹ï¼šå…·ä½“ä»£ç ç‰‡æ®µ

## ğŸ”§ ä¼šè¯é—®é¢˜è§£å†³æ–¹æ¡ˆå®‰å…¨æ‰©å±• - 2025å¹´7æœˆ4æ—¥

### Mockæ•°æ®æ£€æµ‹ä¼˜åŒ–è§„åˆ™ (æ–°å¢ - 2025å¹´7æœˆ4æ—¥)

#### 1. å¢å¼ºMockæ•°æ®æ£€æµ‹ç³»ç»Ÿ
```javascript
// ğŸ”´ å¢å¼ºMockæ•°æ®æ£€æµ‹å™¨
class EnhancedMockDataDetector {
    constructor() {
        this.mockPatterns = {
            basic: [/mock.*data/gi, /fake.*data/gi, /test.*data/gi],
            advanced: [/const.*=.*\[.*\{.*name.*:.*'.*'.*\}.*\]/gi, /setData.*\{.*:.*\[.*\{/gi],
            hidden: [/resolve.*\{.*code.*:.*0/gi, /setTimeout.*resolve/gi],
            miniprogram: [/wx\.showToast.*mock/gi, /success.*res.*data.*=.*\{/gi]
        }
    }
    
    // ğŸ”´ å…¨é¢æ‰«æMockæ•°æ®
    async scanForMockData(projectPath) {
        console.log('ğŸ” å¼€å§‹å¢å¼ºMockæ•°æ®æ£€æµ‹...')
        
        const results = {
            totalFiles: 0,
            violationFiles: [],
            totalViolations: 0,
            patternMatches: {},
            severity: 'UNKNOWN'
        }
        
        // å¹¶è¡Œæ‰«ææ‰€æœ‰æ¨¡å¼
        const scanResults = await Promise.all([
            this.scanPattern(projectPath, 'basic'),
            this.scanPattern(projectPath, 'advanced'),
            this.scanPattern(projectPath, 'hidden'),
            this.scanPattern(projectPath, 'miniprogram')
        ])
        
        scanResults.forEach((result, index) => {
            const patternType = ['basic', 'advanced', 'hidden', 'miniprogram'][index]
            results.patternMatches[patternType] = result
            results.totalViolations += result.violations.length
        })
        
        results.severity = results.totalViolations === 0 ? 'CLEAN' : 
                          results.totalViolations <= 5 ? 'LOW' : 
                          results.totalViolations <= 15 ? 'MEDIUM' : 'HIGH'
        
        return results
    }
}

// ğŸ”´ å…¨å±€å¢å¼ºMockæ£€æµ‹å™¨
const enhancedMockDetector = new EnhancedMockDataDetector()
```

#### 2. ä»»åŠ¡éªŒè¯å®Œæ•´æ€§æ£€æŸ¥ç³»ç»Ÿ
```javascript
// ğŸ”´ ä»»åŠ¡éªŒè¯å®Œæ•´æ€§æ£€æŸ¥ç³»ç»Ÿ
class TaskCompletionValidator {
    constructor() {
        this.validationRules = {
            'code_modification': ['syntax_validation', 'functionality_test', 'integration_check'],
            'security_compliance': ['mock_data_removal', 'sensitive_data_check', 'api_security_validation'],
            'project_health': ['build_success', 'runtime_errors', 'component_integrity']
        }
    }
    
    // ğŸ”´ å…¨é¢ä»»åŠ¡éªŒè¯
    async validateTaskCompletion(taskType, modifiedFiles, projectPath) {
        console.log(`ğŸ” å¼€å§‹ä»»åŠ¡å®ŒæˆéªŒè¯ï¼š${taskType}`)
        
        const validationResults = {
            taskType,
            timestamp: new Date().toISOString(),
            results: {},
            overallScore: 0,
            passed: false,
            issues: [],
            recommendations: []
        }
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰éªŒè¯è§„åˆ™
        const validationPromises = Object.entries(this.validationRules).map(
            async ([category, rules]) => {
                const categoryResults = await this.validateCategory(category, rules, modifiedFiles, projectPath)
                validationResults.results[category] = categoryResults
                return categoryResults
            }
        )
        
        await Promise.all(validationPromises)
        
        // è®¡ç®—æ€»ä½“è¯„åˆ†
        const scores = Object.values(validationResults.results).map(r => r.score)
        validationResults.overallScore = scores.reduce((sum, score) => sum + score, 0) / scores.length
        validationResults.passed = validationResults.overallScore >= 80
        
        return validationResults
    }
}

// ğŸ”´ å…¨å±€ä»»åŠ¡éªŒè¯å™¨
const taskCompletionValidator = new TaskCompletionValidator()
```

---

**æ›´æ–°æ—¶é—´**: 2025å¹´7æœˆ4æ—¥  
**æ–°å¢åŠŸèƒ½**: å¢å¼ºMockæ•°æ®æ£€æµ‹ã€ä»»åŠ¡éªŒè¯å®Œæ•´æ€§æ£€æŸ¥  
**å®‰å…¨ç­‰çº§**: CRITICAL - é˜²æ­¢æ•°æ®å®‰å…¨è¿è§„

å¿…é¡»ä¿®æ­£ä¸ºï¼š
1. ç§»é™¤æ‰€æœ‰ç¡¬ç¼–ç æ•°æ®
2. æ”¹ä¸ºçœŸå®åç«¯APIè°ƒç”¨
3. æ·»åŠ åç«¯å¼‚å¸¸å¤„ç†æœºåˆ¶
4. ä¿®å¤æ–¹æ³•è°ƒç”¨é”™è¯¯
5. æ·»åŠ å±æ€§å®‰å…¨è®¿é—®æ£€æŸ¥

åœ¨ä¿®æ­£è¿è§„é—®é¢˜å‰ï¼Œç¦æ­¢ç»§ç»­å¼€å‘ï¼
```

## ğŸ¯ å¼€å‘æµç¨‹å®‰å…¨æ£€æŸ¥æ¸…å•

### æ¯æ¬¡ä»£ç æäº¤å‰å¿…é¡»ç¡®è®¤
- [ ] æ— ä»»ä½•ç¡¬ç¼–ç ä¸šåŠ¡æ•°æ®
- [ ] æ— ä»»ä½•mock/æ¨¡æ‹Ÿæ•°æ®ä½¿ç”¨
- [ ] æ‰€æœ‰æ•°æ®æ¥æºäºçœŸå®åç«¯API
- [ ] åŒ…å«å®Œæ•´çš„åç«¯å¼‚å¸¸å¤„ç†
- [ ] æ–¹æ³•è°ƒç”¨å®‰å…¨ï¼ˆå¯¼å…¥å‡½æ•°ç›´æ¥è°ƒç”¨ï¼‰
- [ ] å±æ€§è®¿é—®å®‰å…¨ï¼ˆæä¾›åå¤‡å€¼ï¼‰
- [ ] APIå…¼å®¹æ€§æ£€æŸ¥å·²å®æ–½
- [ ] åŒ…å«è¯¦ç»†ä»£ç æ³¨é‡Š
- [ ] å¼ºåˆ¶æ•°æ®å­˜åœ¨æ€§æ£€æŸ¥å·²å®æ–½
- [ ] æµ‹è¯•æ•°æ®ä¸ç”Ÿäº§æ•°æ®ç»“æ„åŒæ­¥
- [ ] é¡¹ç›®å¯ä»¥æ­£å¸¸è¿è¡Œ
- [ ] ä¸´æ—¶æ–‡ä»¶å·²æ¸…ç†

## ğŸ¯ è§„åˆ™ä¼˜å…ˆçº§ï¼šæœ€é«˜ - è¿åä»»ä½•ä¸€æ¡è§„åˆ™ï¼Œç«‹å³åœæ­¢å¼€å‘å¹¶ä¿®æ­£ï¼

---
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ2æ—¥  
**é€‚ç”¨é¡¹ç›®**: å¤©å·¥å‰ç«¯é¡¹ç›®ï¼ˆå¾®ä¿¡å°ç¨‹åºï¼‰  
**ç»´æŠ¤è´£ä»»**: å¿…é¡»ä¸¥æ ¼æ‰§è¡Œï¼Œä¸å…è®¸ä»»ä½•ä¾‹å¤–  
**æ•´åˆçŠ¶æ€**: ç»Ÿä¸€æ•´åˆcode-quality-runtime-safety.mdcå’Œtiangong-data-security-core.mdc

## ğŸ¯ Mockæ•°æ®æ£€æµ‹ä¸ä¿®å¤è§„åˆ™

### ğŸ”´ Mockæ•°æ®è‡ªåŠ¨æ£€æµ‹è§„åˆ™ - 2025å¹´1æœˆ3æ—¥æ–°å¢

#### æ£€æµ‹å…³é”®å­—åˆ—è¡¨
```javascript
// éœ€è¦è‡ªåŠ¨æ£€æµ‹çš„Mockæ•°æ®å…³é”®å­—
const MOCK_DETECTION_KEYWORDS = [
  // ç›´æ¥Mockå…³é”®å­—
  'mock', 'Mock', 'MOCK',
  'fake', 'Fake', 'FAKE',
  'test', 'Test', 'TEST',
  'demo', 'Demo', 'DEMO',
  
  // Mockå‡½æ•°æ¨¡å¼
  'mockUser', 'mockData', 'mockList',
  'generateMock', 'createMock', 'mockResponse',
  'shouldUseMock', 'smartApiCall', 'mockRequest',
  
  // æ¨¡æ‹Ÿæ•°æ®æ¨¡å¼
  'mockHistory', 'mockStats', 'mockAvatarUrl',
  'mockLoginData', 'mockProducts', 'mockRecords',
  
  // å¼€å‘ç¯å¢ƒåˆ¤æ–­
  'if (app.globalData.isDev)', 'isDevelopmentMode',
  'developmentMode', 'skipSmsVerification'
]
```

#### ğŸ› ï¸ ä¿®å¤æ ‡å‡†æ¨¡å¼
```javascript
// ä¿®å¤å‰ï¼šè¿è§„çš„Mockæ•°æ®ä½¿ç”¨
loadUploadHistory() {
  if (app.globalData.isDev) {
    const mockHistory = [...]
    this.setData({ uploadHistory: mockHistory })
  } else {
    // çœŸå®APIè°ƒç”¨
  }
}

// ä¿®å¤åï¼šå®Œå…¨ä½¿ç”¨åç«¯API
loadUploadHistory() {
  console.log('ğŸ“¡ è¯·æ±‚ä¸Šä¼ å†å²æ¥å£...')
  
  return uploadAPI.getRecords().then((result) => {
    if (result.code === 0) {
      this.setData({ uploadHistory: result.data.list })
      console.log('âœ… ä¸Šä¼ å†å²åŠ è½½æˆåŠŸ')
    } else {
      throw new Error('âš ï¸ åç«¯æœåŠ¡å¼‚å¸¸ï¼š' + result.msg)
    }
  }).catch((error) => {
    console.error('âŒ è·å–ä¸Šä¼ å†å²å¤±è´¥:', error)
    
    wx.showModal({
      title: 'ğŸš¨ åç«¯æœåŠ¡å¼‚å¸¸',
      content: 'æ— æ³•è·å–ä¸Šä¼ å†å²ï¼\n\nè¯·æ£€æŸ¥åç«¯APIæœåŠ¡çŠ¶æ€ï¼š\nGET /api/photo/history',
      showCancel: false,
      confirmText: 'çŸ¥é“äº†',
      confirmColor: '#ff4444'
    })
    
    this.setData({ uploadHistory: [] })
  })
}
```

### ğŸ”´ Mockæ•°æ®ä¿®å¤æ£€æŸ¥æ¸…å•

#### ä¿®å¤éªŒè¯æ ‡å‡†
```markdown
# Mockæ•°æ®ä¿®å¤å®ŒæˆéªŒè¯æ¸…å•

âœ… åˆ é™¤æ‰€æœ‰Mockæ•°æ®å£°æ˜
âœ… åˆ é™¤æ‰€æœ‰Mockå‡½æ•°å®šä¹‰
âœ… åˆ é™¤æ‰€æœ‰å¼€å‘ç¯å¢ƒåˆ¤æ–­åˆ†æ”¯
âœ… ç»Ÿä¸€ä½¿ç”¨åç«¯APIè°ƒç”¨
âœ… æ·»åŠ å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶
âœ… æ·»åŠ ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
âœ… è®¾ç½®å®‰å…¨çš„é»˜è®¤æ•°æ®
âœ… æ·»åŠ APIè°ƒç”¨æ—¥å¿—è®°å½•

# ä¿®å¤åçš„ä»£ç ç‰¹å¾
- æ— ä»»ä½•Mockå…³é”®å­—
- 100%ä½¿ç”¨çœŸå®API
- å®Œæ•´çš„é”™è¯¯å¤„ç†
- æ¸…æ™°çš„æ—¥å¿—è®°å½•
```

## ğŸ¯ ä»£ç è´¨é‡æ§åˆ¶è§„åˆ™

### ğŸ”´ ä»£ç ä¿®å¤å·¥å…·ä½¿ç”¨è§„èŒƒ - 2025å¹´1æœˆ3æ—¥æ–°å¢

#### search_replaceå·¥å…·ç²¾ç¡®åŒ¹é…è§„åˆ™
```markdown
# ä½¿ç”¨search_replaceå·¥å…·çš„ç²¾ç¡®åŒ¹é…è¦æ±‚

1. å¿…é¡»åŒ…å«å®Œæ•´çš„ä¸Šä¸‹æ–‡ï¼ˆ3-5è¡Œï¼‰
2. ç²¾ç¡®åŒ¹é…æ‰€æœ‰ç©ºæ ¼ã€æ¢è¡Œç¬¦
3. åŒ…å«å®Œæ•´çš„æ³¨é‡Šå†…å®¹
4. åŒ¹é…å¤±è´¥æ—¶å…ˆä½¿ç”¨read_fileç¡®è®¤å†…å®¹
5. å¯¹äºå¤æ‚çš„ä»£ç å—ï¼Œåˆ†æ­¥éª¤ä¿®å¤

# å¸¸è§åŒ¹é…å¤±è´¥åŸå› 
- å¿½ç•¥äº†ä»£ç ä¸­çš„æ³¨é‡Š
- ç©ºæ ¼å’Œæ¢è¡Œç¬¦ä¸åŒ¹é…
- å­—ç¬¦ä¸²è¾¹ç•Œä¸å®Œæ•´
- ä»£ç æ ¼å¼åŒ–å·®å¼‚
```

#### ğŸ› ï¸ ä»£ç ä¿®å¤æœ€ä½³å®è·µ
```javascript
// ä¿®å¤å‰ï¼šå…ˆç¡®è®¤ä»£ç ç»“æ„
read_file('target.js', lines 100-150)

// ä¿®å¤ä¸­ï¼šä½¿ç”¨ç²¾ç¡®çš„å­—ç¬¦ä¸²åŒ¹é…
search_replace('target.js', 
  'å®Œæ•´çš„æ—§ä»£ç å—ï¼ˆåŒ…å«æ³¨é‡Šå’Œç©ºè¡Œï¼‰',
  'ä¿®å¤åçš„æ–°ä»£ç å—'
)

// ä¿®å¤åï¼šéªŒè¯ä¿®å¤ç»“æœ
read_file('target.js', lines 100-150)
```

## ğŸ¯ å®‰å…¨å®¡è®¡è§„åˆ™

### ğŸ”´ é¡¹ç›®å®‰å…¨å®¡è®¡æµç¨‹ - 2025å¹´1æœˆ3æ—¥æ–°å¢

#### å®‰å…¨å®¡è®¡æ£€æŸ¥ç‚¹
```markdown
# å®Œæ•´çš„å®‰å…¨å®¡è®¡æ£€æŸ¥æ¸…å•

## ç¬¬ä¸€é˜¶æ®µï¼šMockæ•°æ®æ£€æµ‹
1. ä½¿ç”¨grep_searchæœç´¢æ‰€æœ‰Mockå…³é”®å­—
2. æ£€æŸ¥æ¯ä¸ªåŒ¹é…ç»“æœçš„ä¸Šä¸‹æ–‡
3. ç¡®è®¤æ˜¯å¦è¿åæ•°æ®å®‰å…¨è§„åˆ™
4. è®°å½•éœ€è¦ä¿®å¤çš„æ–‡ä»¶å’Œè¡Œæ•°

## ç¬¬äºŒé˜¶æ®µï¼šAPIè°ƒç”¨éªŒè¯
1. æ£€æŸ¥æ‰€æœ‰APIè°ƒç”¨æ˜¯å¦ä½¿ç”¨çœŸå®åç«¯
2. éªŒè¯é”™è¯¯å¤„ç†æœºåˆ¶æ˜¯å¦å®Œæ•´
3. ç¡®è®¤ç”¨æˆ·æç¤ºæ˜¯å¦å‹å¥½
4. æ£€æŸ¥é»˜è®¤æ•°æ®æ˜¯å¦å®‰å…¨

## ç¬¬ä¸‰é˜¶æ®µï¼šä»£ç è´¨é‡æ£€æŸ¥
1. éªŒè¯ä»£ç æ³¨é‡Šæ˜¯å¦å®Œæ•´
2. æ£€æŸ¥å‡½æ•°å‘½åæ˜¯å¦è§„èŒƒ
3. ç¡®è®¤ä»£ç ç»“æ„æ˜¯å¦æ¸…æ™°
4. éªŒè¯æ€§èƒ½æ˜¯å¦ä¼˜åŒ–

## ç¬¬å››é˜¶æ®µï¼šåŠŸèƒ½å®Œæ•´æ€§éªŒè¯
1. æ£€æŸ¥æ‰€æœ‰é¡µé¢åŠŸèƒ½æ˜¯å¦æ­£å¸¸
2. éªŒè¯ç”¨æˆ·æ“ä½œæµç¨‹æ˜¯å¦é¡ºç•…
3. ç¡®è®¤æ•°æ®åŒæ­¥æ˜¯å¦åŠæ—¶
4. æ£€æŸ¥å¼‚å¸¸æƒ…å†µå¤„ç†æ˜¯å¦å®Œå–„
```

#### ğŸ› ï¸ å®‰å…¨å®¡è®¡å·¥å…·ä½¿ç”¨
```bash
# æ‰¹é‡æ£€æµ‹Mockæ•°æ®
grep_search("mock|Mock|MOCK|fake|demo|test", include_pattern="*.js")

# æ£€æµ‹ç¡¬ç¼–ç æ•°æ®
grep_search("const.*=.*\\[.*\\]", include_pattern="*.js")

# æ£€æµ‹å¼€å‘ç¯å¢ƒåˆ¤æ–­
grep_search("isDev|developmentMode|globalData\\.isDev", include_pattern="*.js")

# æ£€æµ‹æ¨¡æ‹Ÿæ•°æ®å‡½æ•°
grep_search("generate.*Mock|create.*Mock|mock.*Data", include_pattern="*.js")
```

## ğŸ¯ è§„åˆ™æ‰§è¡Œä¸ç›‘æ§

### ğŸ”´ è§„åˆ™æ‰§è¡Œè‡ªåŠ¨åŒ– - 2025å¹´1æœˆ3æ—¥æ–°å¢

#### è‡ªåŠ¨åŒ–æ£€æŸ¥è„šæœ¬
```javascript
// è‡ªåŠ¨åŒ–å®‰å…¨æ£€æŸ¥è„šæœ¬ç¤ºä¾‹
const securityCheck = {
  async checkMockData() {
    const results = await grep_search("mock|Mock|MOCK", "*.js")
    return results.length === 0 ? 'âœ… é€šè¿‡' : 'âŒ å‘ç°Mockæ•°æ®'
  },
  
  async checkApiCalls() {
    const results = await grep_search("api\\.", "*.js")
    return results.length > 0 ? 'âœ… é€šè¿‡' : 'âŒ ç¼ºå°‘APIè°ƒç”¨'
  },
  
  async checkErrorHandling() {
    const results = await grep_search("catch.*error", "*.js")
    return results.length > 0 ? 'âœ… é€šè¿‡' : 'âŒ ç¼ºå°‘é”™è¯¯å¤„ç†'
  }
}
```

#### è§„åˆ™éµå¾ªéªŒè¯
```markdown
# è§„åˆ™éµå¾ªéªŒè¯æ–¹æ³•

1. å®šæœŸæ‰§è¡Œå®‰å…¨å®¡è®¡æ£€æŸ¥
2. éªŒè¯æ‰€æœ‰ä¿®å¤æ˜¯å¦ç¬¦åˆæ ‡å‡†
3. ç¡®è®¤æ–°å¢ä»£ç æ˜¯å¦éµå¾ªè§„åˆ™
4. æ£€æŸ¥è§„åˆ™æ–‡æ¡£æ˜¯å¦åŠæ—¶æ›´æ–°

# è§„åˆ™è¿åå¤„ç†æµç¨‹
1. ç«‹å³åœæ­¢ç›¸å…³å¼€å‘å·¥ä½œ
2. è¯¦ç»†è®°å½•è¿è§„å†…å®¹å’Œä½ç½®
3. æŒ‰ç…§æ ‡å‡†æ¨¡å¼è¿›è¡Œä¿®å¤
4. éªŒè¯ä¿®å¤ç»“æœç¬¦åˆè¦æ±‚
5. æ›´æ–°ç›¸å…³æ–‡æ¡£å’Œè§„åˆ™
```

---

**æœ€ç»ˆæ›´æ–°æ—¶é—´**: 2025å¹´7æœˆ4æ—¥  
**æœ€ç»ˆæ›´æ–°å†…å®¹**: å®Œæˆå‰ç«¯èŠå¤©è§„åˆ™æ•´ç†é—®é¢˜åˆ†æï¼Œæ–°å¢Mockæ•°æ®æ£€æµ‹å®Œå–„ã€WebSocketé”™è¯¯å¤„ç†ä¼˜åŒ–ã€ä»£ç è´¨é‡æ£€æŸ¥å¼ºåŒ–è§„åˆ™  
**ç»´æŠ¤çŠ¶æ€**: å®Œæˆ - æ‰€æœ‰è§„åˆ™å·²ç”Ÿæ•ˆï¼Œé¡¹ç›®ä¿®å¤å®Œæ¯•

## ğŸ†• 2025å¹´7æœˆ4æ—¥æ–°å¢è§„åˆ™ - åŸºäºå‰ç«¯èŠå¤©è§„åˆ™æ•´ç†é—®é¢˜åˆ†æ

### 7. ğŸ•µï¸ Mockæ•°æ®æ£€æµ‹å®Œå–„è§„åˆ™

#### å…¨é¢Mockæ•°æ®æ£€æµ‹ç³»ç»Ÿ
```javascript
// ğŸ”´ Mockæ•°æ®æ£€æµ‹å™¨ - å®Œå–„ç‰ˆ
class MockDataDetector {
    constructor() {
        this.mockKeywords = [
            // åŸºç¡€Mockå…³é”®è¯
            'mock', 'Mock', 'MOCK',
            'fake', 'Fake', 'FAKE',
            'test', 'Test', 'TEST',
            'demo', 'Demo', 'DEMO',
            'sample', 'Sample', 'SAMPLE',
            'dummy', 'Dummy', 'DUMMY',
            
            // æ¨¡æ‹Ÿå‡½æ•°å…³é”®è¯
            'mockData', 'mockAPI', 'mockResponse',
            'fakeData', 'fakeAPI', 'fakeResponse',
            'testData', 'testAPI', 'testResponse',
            'demoData', 'demoAPI', 'demoResponse',
            'sampleData', 'sampleAPI', 'sampleResponse',
            
            // æ¨¡æ‹Ÿå¯¹è±¡å…³é”®è¯
            'mockUser', 'mockConfig', 'mockResult',
            'fakeUser', 'fakeConfig', 'fakeResult',
            'testUser', 'testConfig', 'testResult',
            
            // æ¡ä»¶åˆ¤æ–­å…³é”®è¯
            'shouldUseMock', 'useMockData', 'isMockMode',
            'shouldUseFake', 'useFakeData', 'isFakeMode',
            'shouldUseTest', 'useTestData', 'isTestMode',
            
            // setTimeoutæ¨¡æ‹Ÿå¼‚æ­¥
            'setTimeout.*callback', 'setTimeout.*resolve',
            'setTimeout.*mockData', 'setTimeout.*fakeData'
        ]
        
        this.mockPatterns = [
            // å‡½æ•°å®šä¹‰æ¨¡å¼
            /const\s+mock\w+\s*=/gi,
            /function\s+mock\w+/gi,
            /const\s+fake\w+\s*=/gi,
            /function\s+fake\w+/gi,
            
            // æ¡ä»¶åˆ¤æ–­æ¨¡å¼
            /if\s*\(\s*\w*mock\w*/gi,
            /if\s*\(\s*\w*fake\w*/gi,
            /if\s*\(\s*\w*test\w*/gi,
            
            // ä¸‰å…ƒè¿ç®—ç¬¦æ¨¡å¼
            /\?\s*mock\w+\s*:/gi,
            /\?\s*fake\w+\s*:/gi,
            /:\s*mock\w+/gi,
            /:\s*fake\w+/gi,
            
            // setTimeoutæ¨¡æ‹Ÿå¼‚æ­¥æ¨¡å¼
            /setTimeout\s*\(\s*\(\)\s*=>\s*{[\s\S]*?callback/gi,
            /setTimeout\s*\(\s*function\s*\(\)\s*{[\s\S]*?callback/gi,
            
            // ç¡¬ç¼–ç æ•°æ®æ¨¡å¼
            /const\s+\w+\s*=\s*\[[\s\S]*?\]/gi,  // æ•°ç»„ç¡¬ç¼–ç 
            /const\s+\w+\s*=\s*{[\s\S]*?}/gi,   // å¯¹è±¡ç¡¬ç¼–ç 
        ]
        
        this.violations = []
    }
    
    // ğŸ”´ å…¨é¢æ£€æµ‹Mockæ•°æ®
    detectMockData(fileContent, filePath) {
        console.log(`ğŸ” æ£€æµ‹Mockæ•°æ®ï¼š${filePath}`)
        
        const violations = []
        
        // æ£€æµ‹å…³é”®è¯
        for (const keyword of this.mockKeywords) {
            if (fileContent.includes(keyword)) {
                const lines = this.findLinesWithKeyword(fileContent, keyword)
                violations.push({
                    type: 'MOCK_KEYWORD',
                    keyword: keyword,
                    file: filePath,
                    lines: lines,
                    severity: 'HIGH'
                })
            }
        }
        
        // æ£€æµ‹æ¨¡å¼
        for (const pattern of this.mockPatterns) {
            const matches = fileContent.match(pattern)
            if (matches) {
                violations.push({
                    type: 'MOCK_PATTERN',
                    pattern: pattern.toString(),
                    matches: matches,
                    file: filePath,
                    severity: 'CRITICAL'
                })
            }
        }
        
        // æ£€æµ‹ç¡¬ç¼–ç æ•°æ®
        const hardcodedData = this.detectHardcodedData(fileContent, filePath)
        violations.push(...hardcodedData)
        
        return violations
    }
    
    // ğŸ”´ ç”Ÿæˆä¿®å¤å»ºè®®
    generateFixSuggestions(violations) {
        const suggestions = []
        
        for (const violation of violations) {
            switch (violation.type) {
                case 'MOCK_KEYWORD':
                    suggestions.push({
                        file: violation.file,
                        lines: violation.lines,
                        suggestion: `ç§»é™¤Mockå…³é”®è¯"${violation.keyword}"ï¼Œä½¿ç”¨çœŸå®APIè°ƒç”¨`,
                        example: 'api.getData().then(result => { /* ä½¿ç”¨çœŸå®æ•°æ® */ })'
                    })
                    break
                    
                case 'MOCK_PATTERN':
                    suggestions.push({
                        file: violation.file,
                        suggestion: 'ç§»é™¤Mockå‡½æ•°/æ¡ä»¶åˆ¤æ–­ï¼Œç›´æ¥è°ƒç”¨åç«¯API',
                        example: 'ç›´æ¥ä½¿ç”¨ï¼šuserAPI.login(params) æ›¿ä»£ mockLogin(params)'
                    })
                    break
                    
                case 'HARDCODED_DATA':
                    suggestions.push({
                        file: violation.file,
                        lines: `${violation.startLine}-${violation.endLine}`,
                        suggestion: 'ç§»é™¤ç¡¬ç¼–ç æ•°æ®ï¼Œä»åç«¯APIè·å–',
                        example: 'api.getConfig().then(config => { this.setData(config) })'
                    })
                    break
            }
        }
        
        return suggestions
    }
}

// ğŸ”´ å…¨å±€Mockæ•°æ®æ£€æµ‹å™¨
const mockDataDetector = new MockDataDetector()
```

### 8. ğŸ”„ WebSocketè¿æ¥é”™è¯¯å¤„ç†ä¼˜åŒ–è§„åˆ™

#### WebSocketé”™è¯¯å¤„ç†å®‰å…¨ç®¡ç†å™¨
```javascript
// ğŸ”´ WebSocketé”™è¯¯å¤„ç†ç®¡ç†å™¨
class WebSocketErrorManager {
    constructor() {
        this.connectionState = {
            isConnected: false,
            isConnecting: false,
            reconnectAttempts: 0,
            lastError: null,
            silentMode: false
        }
        
        this.config = {
            maxReconnectAttempts: 3,
            reconnectInterval: 5000,
            connectionTimeout: 10000,
            heartbeatInterval: 30000,
            developmentMode: this.isDevelopmentEnvironment()
        }
        
        this.errorTypes = {
            CONNECTION_FAILED: 'connection_failed',
            CONNECTION_TIMEOUT: 'connection_timeout', 
            AUTHENTICATION_FAILED: 'authentication_failed',
            NETWORK_ERROR: 'network_error',
            SERVER_ERROR: 'server_error'
        }
    }
    
    // ğŸ”´ æ£€æµ‹æ˜¯å¦ä¸ºå¼€å‘ç¯å¢ƒ
    isDevelopmentEnvironment() {
        try {
            const config = require('../config/env').getConfig()
            return config.isDev === true || config.developmentMode?.silentWebSocketErrors === true
        } catch (error) {
            return false
        }
    }
    
    // ğŸ”´ æ™ºèƒ½é”™è¯¯å¤„ç†
    handleConnectionError(error, context = '') {
        this.connectionState.lastError = error
        const errorType = this.classifyError(error)
        
        console.log(`ğŸ” WebSocketé”™è¯¯åˆ†ç±»ï¼š${errorType}`)
        
        if (this.config.developmentMode) {
            // å¼€å‘ç¯å¢ƒé™é»˜å¤„ç†
            this.handleDevelopmentError(error, errorType, context)
        } else {
            // ç”Ÿäº§ç¯å¢ƒæ˜¾ç¤ºé”™è¯¯
            this.handleProductionError(error, errorType, context)
        }
        
        // æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¿
        if (this.shouldReconnect(errorType)) {
            this.scheduleReconnect()
        }
    }
    
    // ğŸ”´ å¼€å‘ç¯å¢ƒé”™è¯¯å¤„ç†
    handleDevelopmentError(error, errorType, context) {
        console.log(`ğŸ”§ å¼€å‘ç¯å¢ƒWebSocketé”™è¯¯ï¼ˆé™é»˜å¤„ç†ï¼‰: ${errorType}`)
        console.log(`ğŸ“ é”™è¯¯ä¸Šä¸‹æ–‡: ${context}`)
        console.log(`ğŸ“ é”™è¯¯è¯¦æƒ…: ${error.message}`)
        
        this.connectionState.silentMode = true
        
        // å¼€å‘ç¯å¢ƒæç¤ºï¼ˆéé˜»æ–­ï¼‰
        if (typeof wx !== 'undefined') {
            wx.showToast({
                title: 'åç«¯æœåŠ¡æ£€æŸ¥ä¸­',
                icon: 'loading',
                duration: 1000,
                mask: false
            })
        }
    }
    
    // ğŸ”´ æ™ºèƒ½é‡è¿æœºåˆ¶
    scheduleReconnect() {
        if (this.connectionState.reconnectAttempts >= this.config.maxReconnectAttempts) {
            console.warn('âš ï¸ WebSocketé‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œåœæ­¢é‡è¿')
            return
        }
        
        this.connectionState.reconnectAttempts++
        
        // æŒ‡æ•°é€€é¿é‡è¿é—´éš”
        const reconnectDelay = this.config.reconnectInterval * Math.pow(2, this.connectionState.reconnectAttempts - 1)
        
        console.log(`ğŸ”„ WebSocketå°†åœ¨${reconnectDelay}msåè¿›è¡Œç¬¬${this.connectionState.reconnectAttempts}æ¬¡é‡è¿`)
        
        setTimeout(() => {
            this.attemptReconnect()
        }, reconnectDelay)
    }
    
    // ğŸ”´ è¿æ¥æˆåŠŸå¤„ç†
    handleConnectionSuccess() {
        this.connectionState.isConnected = true
        this.connectionState.isConnecting = false
        this.connectionState.reconnectAttempts = 0
        this.connectionState.lastError = null
        this.connectionState.silentMode = false
        
        console.log('âœ… WebSocketè¿æ¥æˆåŠŸ')
        
        // å¼€å§‹å¿ƒè·³æ£€æµ‹
        this.startHeartbeat()
        
        // é€šçŸ¥è¿æ¥æˆåŠŸ
        if (!this.config.developmentMode && typeof wx !== 'undefined') {
            wx.showToast({
                title: 'è¿æ¥æˆåŠŸ',
                icon: 'success',
                duration: 1000
            })
        }
    }
}

// ğŸ”´ å…¨å±€WebSocketé”™è¯¯ç®¡ç†å™¨
const wsErrorManager = new WebSocketErrorManager()
```

### 9. ğŸ” ä»£ç è´¨é‡æ£€æŸ¥å¼ºåŒ–è§„åˆ™

#### ä»£ç è´¨é‡è‡ªåŠ¨æ£€æŸ¥å™¨
```javascript
// ğŸ”´ ä»£ç è´¨é‡æ£€æŸ¥å™¨
class CodeQualityChecker {
    constructor() {
        this.qualityRules = {
            COMMENT_COVERAGE: {
                threshold: 0.8, // 80%çš„å‡½æ•°éœ€è¦æ³¨é‡Š
                severity: 'MEDIUM'
            },
            FUNCTION_COMPLEXITY: {
                maxLines: 50, // å•ä¸ªå‡½æ•°æœ€å¤§è¡Œæ•°
                severity: 'HIGH'
            },
            ERROR_HANDLING: {
                requiredPatterns: ['try', 'catch', '.catch('], 
                severity: 'HIGH'
            },
            SECURITY_COMPLIANCE: {
                prohibitedPatterns: ['mock', 'fake', 'hardcode'],
                severity: 'CRITICAL'
            }
        }
    }
    
    // ğŸ”´ å…¨é¢ä»£ç è´¨é‡æ£€æŸ¥
    performQualityCheck(fileContent, filePath) {
        const results = {
            file: filePath,
            score: 100,
            issues: [],
            warnings: [],
            suggestions: []
        }
        
        // æ£€æŸ¥æ³¨é‡Šè¦†ç›–ç‡
        const commentCoverage = this.checkCommentCoverage(fileContent)
        if (commentCoverage < this.qualityRules.COMMENT_COVERAGE.threshold) {
            results.issues.push({
                type: 'COMMENT_COVERAGE',
                severity: 'MEDIUM',
                message: `æ³¨é‡Šè¦†ç›–ç‡è¿‡ä½ï¼š${(commentCoverage * 100).toFixed(1)}%`,
                suggestion: 'ä¸ºå‡½æ•°å’Œå…³é”®é€»è¾‘æ·»åŠ è¯¦ç»†çš„ä¸­æ–‡æ³¨é‡Š'
            })
            results.score -= 15
        }
        
        // æ£€æŸ¥å‡½æ•°å¤æ‚åº¦
        const complexFunctions = this.checkFunctionComplexity(fileContent)
        if (complexFunctions.length > 0) {
            results.issues.push({
                type: 'FUNCTION_COMPLEXITY',
                severity: 'HIGH',
                message: `å‘ç°${complexFunctions.length}ä¸ªå¤æ‚å‡½æ•°`,
                functions: complexFunctions,
                suggestion: 'å°†å¤æ‚å‡½æ•°æ‹†åˆ†ä¸ºå¤šä¸ªå°å‡½æ•°'
            })
            results.score -= complexFunctions.length * 10
        }
        
        return results
    }
    
    // ğŸ”´ æ£€æŸ¥æ³¨é‡Šè¦†ç›–ç‡
    checkCommentCoverage(content) {
        const lines = content.split('\n')
        const functions = this.extractFunctions(content)
        const commentedFunctions = functions.filter(func => 
            this.hasMeaningfulComment(func, lines)
        )
        
        return functions.length > 0 ? commentedFunctions.length / functions.length : 1
    }
    
    // ğŸ”´ æå–å‡½æ•°å®šä¹‰
    extractFunctions(content) {
        const functionPatterns = [
            /function\s+(\w+)\s*\(/g,           // function name()
            /(\w+)\s*:\s*function\s*\(/g,      // name: function()
            /(\w+)\s*\(\s*.*?\s*\)\s*{/g,      // name() { (ç®­å¤´å‡½æ•°ç®€åŒ–å½¢å¼)
            /const\s+(\w+)\s*=\s*\(.*?\)\s*=>/g // const name = () =>
        ]
        
        const functions = []
        
        for (const pattern of functionPatterns) {
            let match
            while ((match = pattern.exec(content)) !== null) {
                functions.push({
                    name: match[1],
                    start: match.index,
                    pattern: match[0]
                })
            }
        }
        
        return functions
    }
}

// ğŸ”´ å…¨å±€ä»£ç è´¨é‡æ£€æŸ¥å™¨
const codeQualityChecker = new CodeQualityChecker()
```

---

## ğŸ†• 2025å¹´7æœˆ4æ—¥æ–°å¢è§„åˆ™ - åŸºäºå‰ç«¯èŠå¤©è§„åˆ™æ•´ç†é—®é¢˜åˆ†æ

### 7. ğŸ•µï¸ Mockæ•°æ®æ£€æµ‹å®Œå–„è§„åˆ™

#### å…¨é¢Mockæ•°æ®æ£€æµ‹ç³»ç»Ÿ
```javascript
// ğŸ”´ Mockæ•°æ®æ£€æµ‹å™¨ - å®Œå–„ç‰ˆ
class MockDataDetector {
    constructor() {
        this.mockKeywords = [
            // åŸºç¡€Mockå…³é”®è¯
            'mock', 'Mock', 'MOCK',
            'fake', 'Fake', 'FAKE',
            'test', 'Test', 'TEST',
            'demo', 'Demo', 'DEMO',
            'sample', 'Sample', 'SAMPLE',
            'dummy', 'Dummy', 'DUMMY',
            
            // æ¨¡æ‹Ÿå‡½æ•°å…³é”®è¯
            'mockData', 'mockAPI', 'mockResponse',
            'fakeData', 'fakeAPI', 'fakeResponse',
            'testData', 'testAPI', 'testResponse',
            'demoData', 'demoAPI', 'demoResponse',
            'sampleData', 'sampleAPI', 'sampleResponse',
            
            // æ¨¡æ‹Ÿå¯¹è±¡å…³é”®è¯
            'mockUser', 'mockConfig', 'mockResult',
            'fakeUser', 'fakeConfig', 'fakeResult',
            'testUser', 'testConfig', 'testResult',
            
            // æ¡ä»¶åˆ¤æ–­å…³é”®è¯
            'shouldUseMock', 'useMockData', 'isMockMode',
            'shouldUseFake', 'useFakeData', 'isFakeMode',
            'shouldUseTest', 'useTestData', 'isTestMode',
            
            // setTimeoutæ¨¡æ‹Ÿå¼‚æ­¥
            'setTimeout.*callback', 'setTimeout.*resolve',
            'setTimeout.*mockData', 'setTimeout.*fakeData'
        ]
        
        this.mockPatterns = [
            // å‡½æ•°å®šä¹‰æ¨¡å¼
            /const\s+mock\w+\s*=/gi,
            /function\s+mock\w+/gi,
            /const\s+fake\w+\s*=/gi,
            /function\s+fake\w+/gi,
            
            // æ¡ä»¶åˆ¤æ–­æ¨¡å¼
            /if\s*\(\s*\w*mock\w*/gi,
            /if\s*\(\s*\w*fake\w*/gi,
            /if\s*\(\s*\w*test\w*/gi,
            
            // ä¸‰å…ƒè¿ç®—ç¬¦æ¨¡å¼
            /\?\s*mock\w+\s*:/gi,
            /\?\s*fake\w+\s*:/gi,
            /:\s*mock\w+/gi,
            /:\s*fake\w+/gi,
            
            // setTimeoutæ¨¡æ‹Ÿå¼‚æ­¥æ¨¡å¼
            /setTimeout\s*\(\s*\(\)\s*=>\s*{[\s\S]*?callback/gi,
            /setTimeout\s*\(\s*function\s*\(\)\s*{[\s\S]*?callback/gi,
            
            // ç¡¬ç¼–ç æ•°æ®æ¨¡å¼
            /const\s+\w+\s*=\s*\[[\s\S]*?\]/gi,  // æ•°ç»„ç¡¬ç¼–ç 
            /const\s+\w+\s*=\s*{[\s\S]*?}/gi,   // å¯¹è±¡ç¡¬ç¼–ç 
        ]
        
        this.violations = []
    }
    
    // ğŸ”´ å…¨é¢æ£€æµ‹Mockæ•°æ®
    detectMockData(fileContent, filePath) {
        console.log(`ğŸ” æ£€æµ‹Mockæ•°æ®ï¼š${filePath}`)
        
        const violations = []
        
        // æ£€æµ‹å…³é”®è¯
        for (const keyword of this.mockKeywords) {
            if (fileContent.includes(keyword)) {
                const lines = this.findLinesWithKeyword(fileContent, keyword)
                violations.push({
                    type: 'MOCK_KEYWORD',
                    keyword: keyword,
                    file: filePath,
                    lines: lines,
                    severity: 'HIGH'
                })
            }
        }
        
        // æ£€æµ‹æ¨¡å¼
        for (const pattern of this.mockPatterns) {
            const matches = fileContent.match(pattern)
            if (matches) {
                violations.push({
                    type: 'MOCK_PATTERN',
                    pattern: pattern.toString(),
                    matches: matches,
                    file: filePath,
                    severity: 'CRITICAL'
                })
            }
        }
        
        // æ£€æµ‹ç¡¬ç¼–ç æ•°æ®
        const hardcodedData = this.detectHardcodedData(fileContent, filePath)
        violations.push(...hardcodedData)
        
        return violations
    }
    
    // ğŸ”´ æ£€æµ‹ç¡¬ç¼–ç æ•°æ®
    detectHardcodedData(fileContent, filePath) {
        const violations = []
        
        // æ£€æµ‹å¤§å‹æ•°ç»„/å¯¹è±¡ç¡¬ç¼–ç 
        const lines = fileContent.split('\n')
        let inDataStructure = false
        let dataStructureStart = -1
        let bracketCount = 0
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i]
            
            // æ£€æµ‹æ•°æ®ç»“æ„å¼€å§‹
            if (/const\s+\w+\s*=\s*[\[{]/.test(line)) {
                inDataStructure = true
                dataStructureStart = i
                bracketCount = (line.match(/[\[{]/g) || []).length - (line.match(/[\]}]/g) || []).length
            }
            
            if (inDataStructure) {
                bracketCount += (line.match(/[\[{]/g) || []).length - (line.match(/[\]}]/g) || []).length
                
                if (bracketCount === 0) {
                    // æ•°æ®ç»“æ„ç»“æŸ
                    const structureSize = i - dataStructureStart + 1
                    
                    if (structureSize > 10) { // è¶…è¿‡10è¡Œçš„æ•°æ®ç»“æ„
                        violations.push({
                            type: 'HARDCODED_DATA',
                            file: filePath,
                            startLine: dataStructureStart + 1,
                            endLine: i + 1,
                            size: structureSize,
                            severity: 'HIGH'
                        })
                    }
                    
                    inDataStructure = false
                }
            }
        }
        
        return violations
    }
    
    // ğŸ”´ ç”Ÿæˆä¿®å¤å»ºè®®
    generateFixSuggestions(violations) {
        const suggestions = []
        
        for (const violation of violations) {
            switch (violation.type) {
                case 'MOCK_KEYWORD':
                    suggestions.push({
                        file: violation.file,
                        lines: violation.lines,
                        suggestion: `ç§»é™¤Mockå…³é”®è¯"${violation.keyword}"ï¼Œä½¿ç”¨çœŸå®APIè°ƒç”¨`,
                        example: 'api.getData().then(result => { /* ä½¿ç”¨çœŸå®æ•°æ® */ })'
                    })
                    break
                    
                case 'MOCK_PATTERN':
                    suggestions.push({
                        file: violation.file,
                        suggestion: 'ç§»é™¤Mockå‡½æ•°/æ¡ä»¶åˆ¤æ–­ï¼Œç›´æ¥è°ƒç”¨åç«¯API',
                        example: 'ç›´æ¥ä½¿ç”¨ï¼šuserAPI.login(params) æ›¿ä»£ mockLogin(params)'
                    })
                    break
                    
                case 'HARDCODED_DATA':
                    suggestions.push({
                        file: violation.file,
                        lines: `${violation.startLine}-${violation.endLine}`,
                        suggestion: 'ç§»é™¤ç¡¬ç¼–ç æ•°æ®ï¼Œä»åç«¯APIè·å–',
                        example: 'api.getConfig().then(config => { this.setData(config) })'
                    })
                    break
            }
        }
        
        return suggestions
    }
}

// ğŸ”´ å…¨å±€Mockæ•°æ®æ£€æµ‹å™¨
const mockDataDetector = new MockDataDetector()

// ğŸ”´ å¼ºåˆ¶Mockæ•°æ®æ£€æŸ¥
const performMockDataCheck = async (projectPath) => {
    console.log('ğŸš¨ å¼€å§‹å…¨é¢Mockæ•°æ®æ£€æŸ¥...')
    
    const jsFiles = await findJSFiles(projectPath)
    const allViolations = []
    
    for (const file of jsFiles) {
        const content = await read_file(file)
        const violations = mockDataDetector.detectMockData(content, file)
        allViolations.push(...violations)
    }
    
    if (allViolations.length > 0) {
        console.error(`ğŸš¨ å‘ç°${allViolations.length}ä¸ªMockæ•°æ®è¿è§„ï¼`)
        
        const suggestions = mockDataDetector.generateFixSuggestions(allViolations)
        console.log('ğŸ’¡ ä¿®å¤å»ºè®®ï¼š')
        suggestions.forEach(suggestion => {
            console.log(`  - ${suggestion.file}: ${suggestion.suggestion}`)
        })
        
        return {
            hasViolations: true,
            violations: allViolations,
            suggestions: suggestions
        }
    }
    
    console.log('âœ… Mockæ•°æ®æ£€æŸ¥é€šè¿‡')
    return {
        hasViolations: false,
        violations: [],
        suggestions: []
    }
}
```

### 8. ğŸ”„ WebSocketè¿æ¥é”™è¯¯å¤„ç†ä¼˜åŒ–è§„åˆ™

#### WebSocketé”™è¯¯å¤„ç†å®‰å…¨ç®¡ç†å™¨
```javascript
// ğŸ”´ WebSocketé”™è¯¯å¤„ç†ç®¡ç†å™¨
class WebSocketErrorManager {
    constructor() {
        this.connectionState = {
            isConnected: false,
            isConnecting: false,
            reconnectAttempts: 0,
            lastError: null,
            silentMode: false
        }
        
        this.config = {
            maxReconnectAttempts: 3,
            reconnectInterval: 5000,
            connectionTimeout: 10000,
            heartbeatInterval: 30000,
            developmentMode: this.isDevelopmentEnvironment()
        }
        
        this.errorTypes = {
            CONNECTION_FAILED: 'connection_failed',
            CONNECTION_TIMEOUT: 'connection_timeout', 
            AUTHENTICATION_FAILED: 'authentication_failed',
            NETWORK_ERROR: 'network_error',
            SERVER_ERROR: 'server_error'
        }
    }
    
    // ğŸ”´ æ£€æµ‹æ˜¯å¦ä¸ºå¼€å‘ç¯å¢ƒ
    isDevelopmentEnvironment() {
        try {
            const config = require('../config/env').getConfig()
            return config.isDev === true || config.developmentMode?.silentWebSocketErrors === true
        } catch (error) {
            return false
        }
    }
    
    // ğŸ”´ æ™ºèƒ½é”™è¯¯å¤„ç†
    handleConnectionError(error, context = '') {
        this.connectionState.lastError = error
        const errorType = this.classifyError(error)
        
        console.log(`ğŸ” WebSocketé”™è¯¯åˆ†ç±»ï¼š${errorType}`)
        
        if (this.config.developmentMode) {
            // å¼€å‘ç¯å¢ƒé™é»˜å¤„ç†
            this.handleDevelopmentError(error, errorType, context)
        } else {
            // ç”Ÿäº§ç¯å¢ƒæ˜¾ç¤ºé”™è¯¯
            this.handleProductionError(error, errorType, context)
        }
        
        // æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¿
        if (this.shouldReconnect(errorType)) {
            this.scheduleReconnect()
        }
    }
    
    // ğŸ”´ é”™è¯¯åˆ†ç±»
    classifyError(error) {
        const errorMessage = error.message || error.toString()
        
        if (errorMessage.includes('timeout')) {
            return this.errorTypes.CONNECTION_TIMEOUT
        } else if (errorMessage.includes('authentication') || errorMessage.includes('auth')) {
            return this.errorTypes.AUTHENTICATION_FAILED
        } else if (errorMessage.includes('network') || errorMessage.includes('ECONNREFUSED')) {
            return this.errorTypes.NETWORK_ERROR
        } else if (errorMessage.includes('server') || errorMessage.includes('5')) {
            return this.errorTypes.SERVER_ERROR
        } else {
            return this.errorTypes.CONNECTION_FAILED
        }
    }
    
    // ğŸ”´ å¼€å‘ç¯å¢ƒé”™è¯¯å¤„ç†
    handleDevelopmentError(error, errorType, context) {
        console.log(`ğŸ”§ å¼€å‘ç¯å¢ƒWebSocketé”™è¯¯ï¼ˆé™é»˜å¤„ç†ï¼‰: ${errorType}`)
        console.log(`ğŸ“ é”™è¯¯ä¸Šä¸‹æ–‡: ${context}`)
        console.log(`ğŸ“ é”™è¯¯è¯¦æƒ…: ${error.message}`)
        
        this.connectionState.silentMode = true
        
        // å¼€å‘ç¯å¢ƒæç¤ºï¼ˆéé˜»æ–­ï¼‰
        if (typeof wx !== 'undefined') {
            wx.showToast({
                title: 'åç«¯æœåŠ¡æ£€æŸ¥ä¸­',
                icon: 'loading',
                duration: 1000,
                mask: false
            })
        }
    }
    
    // ğŸ”´ ç”Ÿäº§ç¯å¢ƒé”™è¯¯å¤„ç†
    handleProductionError(error, errorType, context) {
        console.error(`ğŸš¨ WebSocketè¿æ¥é”™è¯¯: ${errorType}`)
        console.error(`ğŸ“ é”™è¯¯ä¸Šä¸‹æ–‡: ${context}`)
        console.error(`ğŸ“ é”™è¯¯è¯¦æƒ…:`, error)
        
        // ç”Ÿäº§ç¯å¢ƒç”¨æˆ·å‹å¥½æç¤º
        const userMessage = this.generateUserFriendlyMessage(errorType)
        
        if (typeof wx !== 'undefined') {
            wx.showModal({
                title: 'è¿æ¥å¼‚å¸¸',
                content: userMessage,
                showCancel: true,
                cancelText: 'ç¨åé‡è¯•',
                confirmText: 'ç«‹å³é‡è¯•',
                success: (res) => {
                    if (res.confirm) {
                        this.forceReconnect()
                    }
                }
            })
        }
    }
    
    // ğŸ”´ ç”Ÿæˆç”¨æˆ·å‹å¥½é”™è¯¯æ¶ˆæ¯
    generateUserFriendlyMessage(errorType) {
        const messages = {
            [this.errorTypes.CONNECTION_FAILED]: 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œçŠ¶æ€',
            [this.errorTypes.CONNECTION_TIMEOUT]: 'è¿æ¥è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•',
            [this.errorTypes.AUTHENTICATION_FAILED]: 'èº«ä»½éªŒè¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•',
            [this.errorTypes.NETWORK_ERROR]: 'ç½‘ç»œè¿æ¥å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®',
            [this.errorTypes.SERVER_ERROR]: 'æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•'
        }
        
        return messages[errorType] || 'è¿æ¥å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•'
    }
    
    // ğŸ”´ åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¿
    shouldReconnect(errorType) {
        // è®¤è¯å¤±è´¥ä¸é‡è¿
        if (errorType === this.errorTypes.AUTHENTICATION_FAILED) {
            return false
        }
        
        // è¶…è¿‡æœ€å¤§é‡è¿æ¬¡æ•°ä¸é‡è¿
        if (this.connectionState.reconnectAttempts >= this.config.maxReconnectAttempts) {
            return false
        }
        
        return true
    }
    
    // ğŸ”´ æ™ºèƒ½é‡è¿æœºåˆ¶
    scheduleReconnect() {
        if (this.connectionState.reconnectAttempts >= this.config.maxReconnectAttempts) {
            console.warn('âš ï¸ WebSocketé‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼Œåœæ­¢é‡è¿')
            return
        }
        
        this.connectionState.reconnectAttempts++
        
        // æŒ‡æ•°é€€é¿é‡è¿é—´éš”
        const reconnectDelay = this.config.reconnectInterval * Math.pow(2, this.connectionState.reconnectAttempts - 1)
        
        console.log(`ğŸ”„ WebSocketå°†åœ¨${reconnectDelay}msåè¿›è¡Œç¬¬${this.connectionState.reconnectAttempts}æ¬¡é‡è¿`)
        
        setTimeout(() => {
            this.attemptReconnect()
        }, reconnectDelay)
    }
    
    // ğŸ”´ é‡è¿å°è¯•
    attemptReconnect() {
        if (this.connectionState.isConnected) {
            console.log('âœ… WebSocketå·²è¿æ¥ï¼Œå–æ¶ˆé‡è¿')
            return
        }
        
        console.log(`ğŸ”„ å¼€å§‹ç¬¬${this.connectionState.reconnectAttempts}æ¬¡WebSocketé‡è¿...`)
        
        this.connectionState.isConnecting = true
        
        try {
            // å°è¯•é‡æ–°è¿æ¥
            this.connect()
        } catch (error) {
            console.error('âŒ WebSocketé‡è¿å¤±è´¥:', error)
            this.connectionState.isConnecting = false
            
            if (this.connectionState.reconnectAttempts < this.config.maxReconnectAttempts) {
                this.scheduleReconnect()
            } else {
                this.handleMaxReconnectAttemptsReached()
            }
        }
    }
    
    // ğŸ”´ è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°å¤„ç†
    handleMaxReconnectAttemptsReached() {
        console.error('ğŸš¨ WebSocketé‡è¿æ¬¡æ•°å·²è¾¾ä¸Šé™')
        
        if (this.config.developmentMode) {
            console.log('ğŸ”§ å¼€å‘ç¯å¢ƒï¼šWebSocketè¿æ¥å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨HTTP API')
        } else {
            console.error('ğŸš¨ ç”Ÿäº§ç¯å¢ƒï¼šWebSocketè¿æ¥å¤±è´¥ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ')
            
            if (typeof wx !== 'undefined') {
                wx.showModal({
                    title: 'è¿æ¥å¤±è´¥',
                    content: 'æ— æ³•å»ºç«‹å®æ—¶è¿æ¥ï¼Œéƒ¨åˆ†åŠŸèƒ½å¯èƒ½å—å½±å“ã€‚è¯·æ£€æŸ¥ç½‘ç»œæˆ–è”ç³»æŠ€æœ¯æ”¯æŒã€‚',
                    showCancel: false,
                    confirmText: 'çŸ¥é“äº†'
                })
            }
        }
    }
    
    // ğŸ”´ è¿æ¥æˆåŠŸå¤„ç†
    handleConnectionSuccess() {
        this.connectionState.isConnected = true
        this.connectionState.isConnecting = false
        this.connectionState.reconnectAttempts = 0
        this.connectionState.lastError = null
        this.connectionState.silentMode = false
        
        console.log('âœ… WebSocketè¿æ¥æˆåŠŸ')
        
        // å¼€å§‹å¿ƒè·³æ£€æµ‹
        this.startHeartbeat()
        
        // é€šçŸ¥è¿æ¥æˆåŠŸ
        if (!this.config.developmentMode && typeof wx !== 'undefined') {
            wx.showToast({
                title: 'è¿æ¥æˆåŠŸ',
                icon: 'success',
                duration: 1000
            })
        }
    }
    
    // ğŸ”´ å¿ƒè·³æ£€æµ‹
    startHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer)
        }
        
        this.heartbeatTimer = setInterval(() => {
            if (this.connectionState.isConnected) {
                this.sendHeartbeat()
            }
        }, this.config.heartbeatInterval)
    }
    
    // ğŸ”´ å‘é€å¿ƒè·³
    sendHeartbeat() {
        try {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify({
                    type: 'heartbeat',
                    timestamp: Date.now()
                }))
            }
        } catch (error) {
            console.warn('âš ï¸ å¿ƒè·³å‘é€å¤±è´¥:', error)
            this.handleConnectionError(error, 'heartbeat')
        }
    }
    
    // ğŸ”´ è·å–è¿æ¥çŠ¶æ€æŠ¥å‘Š
    getConnectionStatusReport() {
        return {
            ...this.connectionState,
            config: this.config,
            lastUpdateTime: new Date().toISOString()
        }
    }
}

// ğŸ”´ å…¨å±€WebSocketé”™è¯¯ç®¡ç†å™¨
const wsErrorManager = new WebSocketErrorManager()

// ğŸ”´ ä¼˜åŒ–çš„WebSocketè¿æ¥å®ç°
const createOptimizedWebSocket = (url) => {
    console.log('ğŸ”Œ åˆ›å»ºä¼˜åŒ–çš„WebSocketè¿æ¥...')
    
    const socket = new WebSocket(url)
    
    socket.onopen = () => {
        wsErrorManager.handleConnectionSuccess()
    }
    
    socket.onerror = (error) => {
        wsErrorManager.handleConnectionError(error, 'socket_error')
    }
    
    socket.onclose = (event) => {
        wsErrorManager.connectionState.isConnected = false
        console.log(`ğŸ”Œ WebSocketè¿æ¥å·²å…³é—­ (code: ${event.code})`)
        
        // å¦‚æœä¸æ˜¯ä¸»åŠ¨å…³é—­ï¼Œå°è¯•é‡è¿
        if (!wsErrorManager.connectionState.intentionalClose) {
            wsErrorManager.scheduleReconnect()
        }
    }
    
    socket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data)
            handleWebSocketMessage(data)
        } catch (error) {
            console.error('âŒ WebSocketæ¶ˆæ¯è§£æå¤±è´¥:', error)
            wsErrorManager.handleConnectionError(error, 'message_parsing')
        }
    }
    
    // è¿æ¥è¶…æ—¶æ£€æµ‹
    const connectionTimeout = setTimeout(() => {
        if (socket.readyState === WebSocket.CONNECTING) {
            socket.close()
            wsErrorManager.handleConnectionError(
                new Error('Connection timeout'),
                'connection_timeout'
            )
        }
    }, wsErrorManager.config.connectionTimeout)
    
    socket.addEventListener('open', () => {
        clearTimeout(connectionTimeout)
    })
    
    return socket
}
```

### 9. ğŸ” ä»£ç è´¨é‡æ£€æŸ¥å¼ºåŒ–è§„åˆ™

#### ä»£ç è´¨é‡è‡ªåŠ¨æ£€æŸ¥å™¨
```javascript
// ğŸ”´ ä»£ç è´¨é‡æ£€æŸ¥å™¨
class CodeQualityChecker {
    constructor() {
        this.qualityRules = {
            COMMENT_COVERAGE: {
                threshold: 0.8, // 80%çš„å‡½æ•°éœ€è¦æ³¨é‡Š
                severity: 'MEDIUM'
            },
            FUNCTION_COMPLEXITY: {
                maxLines: 50, // å•ä¸ªå‡½æ•°æœ€å¤§è¡Œæ•°
                severity: 'HIGH'
            },
            ERROR_HANDLING: {
                requiredPatterns: ['try', 'catch', '.catch('], 
                severity: 'HIGH'
            },
            SECURITY_COMPLIANCE: {
                prohibitedPatterns: ['mock', 'fake', 'hardcode'],
                severity: 'CRITICAL'
            }
        }
    }
    
    // ğŸ”´ å…¨é¢ä»£ç è´¨é‡æ£€æŸ¥
    performQualityCheck(fileContent, filePath) {
        const results = {
            file: filePath,
            score: 100,
            issues: [],
            warnings: [],
            suggestions: []
        }
        
        // æ£€æŸ¥æ³¨é‡Šè¦†ç›–ç‡
        const commentCoverage = this.checkCommentCoverage(fileContent)
        if (commentCoverage < this.qualityRules.COMMENT_COVERAGE.threshold) {
            results.issues.push({
                type: 'COMMENT_COVERAGE',
                severity: 'MEDIUM',
                message: `æ³¨é‡Šè¦†ç›–ç‡è¿‡ä½ï¼š${(commentCoverage * 100).toFixed(1)}%`,
                suggestion: 'ä¸ºå‡½æ•°å’Œå…³é”®é€»è¾‘æ·»åŠ è¯¦ç»†çš„ä¸­æ–‡æ³¨é‡Š'
            })
            results.score -= 15
        }
        
        // æ£€æŸ¥å‡½æ•°å¤æ‚åº¦
        const complexFunctions = this.checkFunctionComplexity(fileContent)
        if (complexFunctions.length > 0) {
            results.issues.push({
                type: 'FUNCTION_COMPLEXITY',
                severity: 'HIGH',
                message: `å‘ç°${complexFunctions.length}ä¸ªå¤æ‚å‡½æ•°`,
                functions: complexFunctions,
                suggestion: 'å°†å¤æ‚å‡½æ•°æ‹†åˆ†ä¸ºå¤šä¸ªå°å‡½æ•°'
            })
            results.score -= complexFunctions.length * 10
        }
        
        // æ£€æŸ¥é”™è¯¯å¤„ç†
        const errorHandling = this.checkErrorHandling(fileContent)
        if (!errorHandling.adequate) {
            results.issues.push({
                type: 'ERROR_HANDLING',
                severity: 'HIGH',
                message: 'é”™è¯¯å¤„ç†ä¸å……åˆ†',
                details: errorHandling.details,
                suggestion: 'ä¸ºAPIè°ƒç”¨å’Œå…³é”®æ“ä½œæ·»åŠ å®Œæ•´çš„é”™è¯¯å¤„ç†'
            })
            results.score -= 20
        }
        
        return results
    }
    
    // ğŸ”´ æ£€æŸ¥æ³¨é‡Šè¦†ç›–ç‡
    checkCommentCoverage(content) {
        const lines = content.split('\n')
        const functions = this.extractFunctions(content)
        const commentedFunctions = functions.filter(func => 
            this.hasMeaningfulComment(func, lines)
        )
        
        return functions.length > 0 ? commentedFunctions.length / functions.length : 1
    }
    
    // ğŸ”´ æå–å‡½æ•°å®šä¹‰
    extractFunctions(content) {
        const functionPatterns = [
            /function\s+(\w+)\s*\(/g,           // function name()
            /(\w+)\s*:\s*function\s*\(/g,      // name: function()
            /(\w+)\s*\(\s*.*?\s*\)\s*{/g,      // name() { (ç®­å¤´å‡½æ•°ç®€åŒ–å½¢å¼)
            /const\s+(\w+)\s*=\s*\(.*?\)\s*=>/g // const name = () =>
        ]
        
        const functions = []
        
        for (const pattern of functionPatterns) {
            let match
            while ((match = pattern.exec(content)) !== null) {
                functions.push({
                    name: match[1],
                    start: match.index,
                    pattern: match[0]
                })
            }
        }
        
        return functions
    }
    
    // ğŸ”´ æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ„ä¹‰çš„æ³¨é‡Š
    hasMeaningfulComment(func, lines) {
        const lineIndex = this.getLineNumber(func.start, lines)
        
        // æ£€æŸ¥å‡½æ•°å‰3è¡Œæ˜¯å¦æœ‰æ³¨é‡Š
        for (let i = Math.max(0, lineIndex - 3); i < lineIndex; i++) {
            const line = lines[i].trim()
            if (line.startsWith('//') || line.startsWith('/*') || line.startsWith('*')) {
                // æ£€æŸ¥æ³¨é‡Šæ˜¯å¦æœ‰æ„ä¹‰ï¼ˆé•¿åº¦å¤§äº10ä¸”åŒ…å«ä¸­æ–‡æˆ–è¯¦ç»†æè¿°ï¼‰
                if (line.length > 10 && (/[\u4e00-\u9fa5]/.test(line) || line.includes('param') || line.includes('return'))) {
                    return true
                }
            }
        }
        
        return false
    }
    
    // ğŸ”´ è·å–è¡Œå·
    getLineNumber(position, lines) {
        let currentPos = 0
        for (let i = 0; i < lines.length; i++) {
            currentPos += lines[i].length + 1 // +1 for newline
            if (currentPos > position) {
                return i
            }
        }
        return lines.length - 1
    }
}

// ğŸ”´ å…¨å±€ä»£ç è´¨é‡æ£€æŸ¥å™¨
const codeQualityChecker = new CodeQualityChecker()
```

---

**æ›´æ–°æ—¶é—´**: 2025å¹´7æœˆ4æ—¥  
**æ–°å¢è§„åˆ™**: Mockæ•°æ®æ£€æµ‹å®Œå–„ã€WebSocketé”™è¯¯å¤„ç†ä¼˜åŒ–ã€ä»£ç è´¨é‡æ£€æŸ¥å¼ºåŒ–  
**ç›®æ ‡**: æå‡é¡¹ç›®å®‰å…¨æ€§å’Œä»£ç è´¨é‡ï¼Œé˜²æ­¢å¸¸è§é—®é¢˜é‡å¤å‡ºç°





