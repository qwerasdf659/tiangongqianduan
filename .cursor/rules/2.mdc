---
description: 
globs: 
alwaysApply: true
---
# ğŸš¨ æ ¸å¿ƒé—®é¢˜é¢„é˜²è§„åˆ™é›† - $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")

## ğŸ”´ Açº§é—®é¢˜é¢„é˜²è§„åˆ™ï¼ˆä¸¥é‡é—®é¢˜ï¼‰

### 1. å·¥å…·è°ƒç”¨å‚æ•°éªŒè¯å¼ºåˆ¶è§„åˆ™
```javascript
// ğŸ”´ å¼ºåˆ¶å‚æ•°éªŒè¯ç³»ç»Ÿ
class ToolCallValidator {
    static validateReadFile(params) {
        const { start_line_one_indexed, end_line_one_indexed_inclusive } = params
        
        if (start_line_one_indexed < 1) {
            throw new Error('start_line_one_indexedå¿…é¡» >= 1')
        }
        
        if (end_line_one_indexed_inclusive < start_line_one_indexed) {
            throw new Error('end_line_one_indexed_inclusiveå¿…é¡» >= start_line_one_indexed')
        }
        
        const rangeSize = end_line_one_indexed_inclusive - start_line_one_indexed + 1
        if (rangeSize > 1000) {
            throw new Error('å•æ¬¡è¯»å–ä¸è¶…è¿‡1000è¡Œï¼Œè¯·åˆ†æ‰¹è¯»å–')
        }
        
        return true
    }
    
    static validateSearchReplace(params) {
        const { old_string, new_string } = params
        
        if (!old_string || old_string.length < 10) {
            throw new Error('old_stringå¿…é¡»åŒ…å«è¶³å¤Ÿä¸Šä¸‹æ–‡(â‰¥10å­—ç¬¦)')
        }
        
        if (old_string === new_string) {
            throw new Error('old_stringå’Œnew_stringä¸èƒ½ç›¸åŒ')
        }
        
        return true
    }
}
```

### 2. 120ç§’è¶…æ—¶å¼ºåˆ¶åˆ‡æ¢è§„åˆ™
```javascript
// ğŸ”´ è¶…æ—¶ç®¡ç†ç³»ç»Ÿ
class TimeoutManager {
    static async executeWithTimeout(operation, fallback, timeout = 120000) {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => {
                reject(new Error(`æ“ä½œè¶…æ—¶${timeout/1000}ç§’ï¼Œè¿å120ç§’è§„åˆ™`))
            }, timeout)
        })
        
        try {
            return await Promise.race([operation(), timeoutPromise])
        } catch (error) {
            if (error.message.includes('è¶…æ—¶')) {
                console.error('ğŸš¨ 120ç§’è¶…æ—¶ï¼Œç«‹å³åˆ‡æ¢å¤‡ç”¨æ–¹æ¡ˆ')
                return await fallback()
            }
            throw error
        }
    }
    
    // ğŸ”´ PowerShellå‘½ä»¤å®‰å…¨æ‰§è¡Œ
    static async safePowerShellCommand(command) {
        const primaryCmd = () => run_terminal_cmd(command)
        const fallbackCmd = () => {
            if (command.length > 80 || /[\u4e00-\u9fa5]/.test(command)) {
                return run_terminal_cmd('ls')  // ç®€åŒ–å‘½ä»¤
            }
            return run_terminal_cmd(command.substring(0, 50))
        }
        
        return await this.executeWithTimeout(primaryCmd, fallbackCmd)
    }
    
    // ğŸ”´ Gitå‘½ä»¤å®‰å…¨æ‰§è¡Œ
    static async safeGitCommand(gitCmd) {
        const primaryCmd = () => run_terminal_cmd(gitCmd)
        const fallbackCmd = () => run_terminal_cmd(`git --no-pager ${gitCmd.replace('git ', '')}`)
        
        return await this.executeWithTimeout(primaryCmd, fallbackCmd)
    }
}
```

### 3. å¹¶è¡Œå·¥å…·è°ƒç”¨å¼ºåˆ¶ä¼˜åŒ–è§„åˆ™
```javascript
// ğŸ”´ å¹¶è¡Œè°ƒç”¨æ£€æµ‹å’Œå¼ºåˆ¶ä¼˜åŒ–
class ParallelCallForcer {
    static detectParallelOpportunity(plannedCalls) {
        const parallelableTools = ['read_file', 'grep_search', 'list_dir', 'file_search', 'codebase_search']
        
        const canParallel = plannedCalls.filter(call => 
            parallelableTools.includes(call.tool) && !call.dependsOnPrevious
        )
        
        if (canParallel.length > 1) {
            const timeSaving = (canParallel.length - 1) * 3000
            console.warn(`âš ï¸ å¹¶è¡Œæœºä¼šæ£€æµ‹ï¼š${canParallel.length}ä¸ªè°ƒç”¨å¯å¹¶è¡Œï¼ŒèŠ‚çœ${timeSaving}ms`)
            
            return {
                canOptimize: true,
                calls: canParallel,
                timeSaving,
                recommendation: `ä½¿ç”¨Promise.all()å¹¶è¡Œæ‰§è¡Œ${canParallel.length}ä¸ªè°ƒç”¨`
            }
        }
        
        return { canOptimize: false }
    }
    
    // ğŸ”´ å¼ºåˆ¶å¹¶è¡Œæ‰§è¡Œ
    static async forceParallelExecution(calls) {
        console.log(`ğŸš€ å¼ºåˆ¶å¹¶è¡Œæ‰§è¡Œ${calls.length}ä¸ªå·¥å…·è°ƒç”¨`)
        
        const startTime = Date.now()
        const results = await Promise.all(calls.map(call => call.execute()))
        const endTime = Date.now()
        
        const timeSaved = (calls.length - 1) * 3000 - (endTime - startTime)
        console.log(`âœ… å¹¶è¡Œæ‰§è¡Œå®Œæˆï¼ŒèŠ‚çœ${timeSaved}ms`)
        
        return results
    }
}
```

### 4. æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥å¼ºåˆ¶è§„åˆ™
```javascript
// ğŸ”´ æ–‡ä»¶åˆ›å»ºå‰å¼ºåˆ¶æ£€æŸ¥
class FileCreationValidator {
    static async checkFileExists(filePath) {
        try {
            await read_file(filePath, false, 1, 1)
            return true
        } catch (error) {
            return false
        }
    }
    
    static async validateFileCreation(filePath) {
        const exists = await this.checkFileExists(filePath)
        
        if (exists) {
            throw new Error(`æ–‡ä»¶å·²å­˜åœ¨ï¼š${filePath}ï¼Œç¦æ­¢é‡å¤åˆ›å»º`)
        }
        
        console.log(`âœ… æ–‡ä»¶åˆ›å»ºæ£€æŸ¥é€šè¿‡ï¼š${filePath}`)
        return true
    }
}
```

## ğŸ”´ Bçº§é—®é¢˜é¢„é˜²è§„åˆ™ï¼ˆæ•ˆç‡é—®é¢˜ï¼‰

### 5. é…ç½®é”™è¯¯æ‰¹é‡æ£€æµ‹è§„åˆ™
```javascript
// ğŸ”´ é…ç½®é”™è¯¯æ‰¹é‡æ£€æµ‹ç³»ç»Ÿ
class ConfigErrorBatchDetector {
    static correctDomains = ['rqchrlqndora.sealosbja.site']
    static errorDomains = [
        'rqchrlandora.sealoshqja.site',
        'rqchrlqndora.sealoshqja.site',
        'rqchrlandora.sealosbja.site'
    ]
    
    static filesToCheck = [
        'config/env.js',
        'project.private.config.json',
        'å‰ç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
        'æ¥å£å¯¹æ¥è§„èŒƒæ–‡æ¡£æ ‡å‡†.md',
        'åç«¯æŠ€æœ¯è§„èŒƒæ–‡æ¡£æ ‡å‡†.md'
    ]
    
    static async batchDetectConfigErrors() {
        console.log('ğŸ” æ‰¹é‡æ£€æµ‹é…ç½®é”™è¯¯...')
        
        const errors = []
        
        // ğŸ”´ å¹¶è¡Œæ£€æŸ¥æ‰€æœ‰æ–‡ä»¶
        const checkPromises = this.filesToCheck.map(async file => {
            const content = await read_file(file, true, 1, -1)
            const fileErrors = this.detectDomainErrors(content.content, file)
            return fileErrors
        })
        
        const allErrors = await Promise.all(checkPromises)
        const flatErrors = allErrors.flat()
        
        if (flatErrors.length > 0) {
            console.error(`ğŸš¨ å‘ç°${flatErrors.length}ä¸ªé…ç½®é”™è¯¯`)
            return {
                hasErrors: true,
                errors: flatErrors,
                batchFixPlan: this.generateBatchFixPlan(flatErrors)
            }
        }
        
        return { hasErrors: false }
    }
    
    static detectDomainErrors(content, filename) {
        const errors = []
        
        this.errorDomains.forEach(errorDomain => {
            if (content.includes(errorDomain)) {
                errors.push({
                    file: filename,
                    errorDomain,
                    correctDomain: this.correctDomains[0],
                    type: 'DOMAIN_CONFIG_ERROR'
                })
            }
        })
        
        return errors
    }
    
    static generateBatchFixPlan(errors) {
        const filesWithErrors = [...new Set(errors.map(e => e.file))]
        
        return {
            totalFiles: filesWithErrors.length,
            totalErrors: errors.length,
            operations: errors.map(error => ({
                file: error.file,
                type: 'replace',
                from: error.errorDomain,
                to: error.correctDomain
            })),
            estimatedTime: errors.length * 2000 // 2ç§’æ¯ä¸ªä¿®å¤
        }
    }
}
```

### 6. APIè·¯å¾„é”™è¯¯æ£€æµ‹è§„åˆ™
```javascript
// ğŸ”´ APIè·¯å¾„é”™è¯¯æ£€æµ‹ç³»ç»Ÿ
class APIPathValidator {
    static correctPaths = {
        '/api/auth/verify': '/api/auth/verify-token',
        '/api/user/userinfo': '/api/user/info',
        '/api/lottery/getconfig': '/api/lottery/config'
    }
    
    static async detectAPIErrors() {
        const filesToCheck = ['utils/api.js', 'pages/*/index.js']
        const errors = []
        
        // ğŸ”´ å¹¶è¡Œæ£€æŸ¥APIæ–‡ä»¶
        const checkPromises = filesToCheck.map(async pattern => {
            const files = await this.findFiles(pattern)
            const fileErrors = await Promise.all(
                files.map(file => this.checkFileForAPIErrors(file))
            )
            return fileErrors.flat()
        })
        
        const allErrors = await Promise.all(checkPromises)
        return allErrors.flat()
    }
    
    static async checkFileForAPIErrors(filepath) {
        const content = await read_file(filepath, true, 1, -1)
        const errors = []
        
        Object.entries(this.correctPaths).forEach(([incorrect, correct]) => {
            if (content.content.includes(incorrect)) {
                errors.push({
                    file: filepath,
                    incorrectPath: incorrect,
                    correctPath: correct,
                    type: 'API_PATH_ERROR'
                })
            }
        })
        
        return errors
    }
}
```

### 7. æ–¹æ³•è°ƒç”¨é”™è¯¯æ£€æµ‹è§„åˆ™
```javascript
// ğŸ”´ æ–¹æ³•è°ƒç”¨é”™è¯¯æ£€æµ‹ç³»ç»Ÿ
class MethodCallValidator {
    static dangerousPatterns = [
        'this\\.getTechnicalConfig\\(\\)',
        'this\\.formatDate\\(\\)',
        'this\\.validateForm\\(\\)',
        'this\\.[a-zA-Z]+Config\\(\\)',
        'this\\.[a-zA-Z]+Util\\(\\)'
    ]
    
    static async detectMethodCallErrors() {
        const jsFiles = await this.findJSFiles()
        const errors = []
        
        // ğŸ”´ å¹¶è¡Œæ£€æŸ¥æ‰€æœ‰JSæ–‡ä»¶
        const checkPromises = jsFiles.map(async file => {
            const content = await read_file(file, true, 1, -1)
            return this.checkMethodCalls(content.content, file)
        })
        
        const allErrors = await Promise.all(checkPromises)
        return allErrors.flat()
    }
    
    static checkMethodCalls(content, filename) {
        const errors = []
        
        this.dangerousPatterns.forEach(pattern => {
            const regex = new RegExp(pattern, 'g')
            const matches = content.match(regex)
            
            if (matches) {
                errors.push({
                    file: filename,
                    errorPattern: pattern,
                    matches: matches,
                    type: 'METHOD_CALL_ERROR',
                    suggestion: 'å°†this.method()æ”¹ä¸ºç›´æ¥è°ƒç”¨å¯¼å…¥çš„å‡½æ•°'
                })
            }
        })
        
        return errors
    }
}
```

## ğŸ”´ Cçº§é—®é¢˜é¢„é˜²è§„åˆ™ï¼ˆæµç¨‹é—®é¢˜ï¼‰

### 8. Mockæ•°æ®æ£€æµ‹å®Œå–„è§„åˆ™
```javascript
// ğŸ”´ Mockæ•°æ®é›¶å®¹å¿æ£€æµ‹ç³»ç»Ÿ
class MockDataDetector {
    static mockKeywords = [
        'mock', 'Mock', 'MOCK', 'fake', 'Fake', 'FAKE',
        'test', 'Test', 'TEST', 'demo', 'Demo', 'DEMO',
        'sample', 'Sample', 'SAMPLE', 'dummy', 'Dummy', 'DUMMY',
        'mockData', 'mockAPI', 'mockResponse', 'mockRequest',
        'fakeData', 'fakeAPI', 'fakeResponse', 'fakeRequest',
        'testData', 'testAPI', 'testResponse', 'testRequest',
        'shouldUseMock', 'useMockData', 'isMockMode',
        'mockLogin', 'mockUser', 'mockConfig'
    ]
    
    static mockPatterns = [
        'const\\s+mock\\w+\\s*=',
        'function\\s+mock\\w+',
        'if\\s*\\(\\s*\\w*mock\\w*',
        'setTimeout\\s*\\(\\s*\\(\\)\\s*=>\\s*{[\\s\\S]*?callback',
        'Math\\.random\\(\\)\\s*\\*\\s*\\d+',
        'const\\s+\\w+\\s*=\\s*\\[[\\s\\S]*?probability[\\s\\S]*?\\]'
    ]
    
    static async scanAllFiles() {
        const jsFiles = await this.findJSFiles()
        const errors = []
        
        // ğŸ”´ å¹¶è¡Œæ‰«ææ‰€æœ‰JSæ–‡ä»¶
        const scanPromises = jsFiles.map(async file => {
            const content = await read_file(file, true, 1, -1)
            return this.detectMockData(content.content, file)
        })
        
        const allErrors = await Promise.all(scanPromises)
        return allErrors.flat()
    }
    
    static detectMockData(content, filename) {
        const violations = []
        
        // æ£€æµ‹å…³é”®è¯
        this.mockKeywords.forEach(keyword => {
            if (content.includes(keyword)) {
                violations.push({
                    file: filename,
                    type: 'MOCK_KEYWORD',
                    keyword: keyword,
                    severity: 'HIGH'
                })
            }
        })
        
        // æ£€æµ‹æ¨¡å¼
        this.mockPatterns.forEach(pattern => {
            const regex = new RegExp(pattern, 'gi')
            const matches = content.match(regex)
            
            if (matches) {
                violations.push({
                    file: filename,
                    type: 'MOCK_PATTERN',
                    pattern: pattern,
                    matches: matches,
                    severity: 'CRITICAL'
                })
            }
        })
        
        return violations
    }
}
```

### 9. æ—¥æœŸæ—¶é—´è‡ªåŠ¨è·å–è§„åˆ™
```powershell
# ğŸ”´ å¼ºåˆ¶ä½¿ç”¨PowerShellè·å–å½“å‰æ—¥æœŸ
# âœ… æ­£ç¡®ç”¨æ³•
$currentDate = Get-Date -Format "yyyyå¹´MMæœˆddæ—¥"
$currentVersion = Get-Date -Format "yyyy-MM-dd"

# âŒ ç¦æ­¢æ‰‹åŠ¨è¾“å…¥æ—¥æœŸ
# é”™è¯¯ï¼šæ‰‹åŠ¨å†™å…¥"2025å¹´1æœˆ3æ—¥"
# æ­£ç¡®ï¼šä½¿ç”¨Get-Dateå‘½ä»¤åŠ¨æ€è·å–
```

### 10. æ­£åˆ™è¡¨è¾¾å¼å®‰å…¨å¤„ç†è§„åˆ™
```javascript
// ğŸ”´ æ­£åˆ™è¡¨è¾¾å¼å®‰å…¨å¤„ç†ç³»ç»Ÿ
class RegexSafetyProcessor {
    static emojiMap = {
        'ğŸ”§': '\\\\u{1F527}',
        'ğŸ”—': '\\\\u{1F517}',
        'ğŸ“¨': '\\\\u{1F4E8}',
        'âŒ': '\\\\u{274C}',
        'âœ…': '\\\\u{2705}',
        'ğŸš¨': '\\\\u{1F6A8}',
        'âš ï¸': '\\\\u{26A0}\\\\u{FE0F}'
    }
    
    static createSafeRegex(unsafePattern) {
        let safePattern = unsafePattern
        
        // è½¬ä¹‰emoji
        Object.entries(this.emojiMap).forEach(([emoji, unicode]) => {
            safePattern = safePattern.replace(
                new RegExp(emoji.replace(/[.*+?^${}()|[\]\\]/g, '\\\\$&'), 'g'), 
                unicode
            )
        })
        
        // è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
        safePattern = safePattern.replace(/[.*+?^${}()|[\]\\]/g, '\\\\$&')
        
        return safePattern
    }
    
    static validateRegexPattern(pattern) {
        try {
            new RegExp(pattern)
            return { valid: true }
        } catch (error) {
            return {
                valid: false,
                error: error.message,
                suggestion: 'è¯·æ£€æŸ¥æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ï¼Œç¡®ä¿ç‰¹æ®Šå­—ç¬¦å·²æ­£ç¡®è½¬ä¹‰'
            }
        }
    }
}
```

### 11. æ‰¹é‡é—®é¢˜å¤„ç†å¼•æ“
```javascript
// ğŸ”´ æ‰¹é‡é—®é¢˜å¤„ç†å¼•æ“
class BatchProblemProcessor {
    static problemCategories = {
        'CONFIGURATION': {
            detector: 'ConfigErrorBatchDetector',
            processor: 'ConfigurationBatchFixer',
            priority: 'HIGH'
        },
        'API_PATHS': {
            detector: 'APIPathValidator',
            processor: 'APIPathBatchFixer',
            priority: 'HIGH'
        },
        'METHOD_CALLS': {
            detector: 'MethodCallValidator',
            processor: 'MethodCallBatchFixer',
            priority: 'MEDIUM'
        },
        'MOCK_DATA': {
            detector: 'MockDataDetector',
            processor: 'MockDataRemover',
            priority: 'CRITICAL'
        }
    }
    
    static async processBatchProblems() {
        console.log('ğŸ”„ å¼€å§‹æ‰¹é‡é—®é¢˜å¤„ç†...')
        
        const processingResults = []
        
        // ğŸ”´ å¹¶è¡Œæ£€æµ‹æ‰€æœ‰é—®é¢˜ç±»å‹
        const detectionPromises = Object.entries(this.problemCategories).map(async ([category, config]) => {
            const detector = eval(config.detector)
            const problems = await detector.detect()
            
            return {
                category,
                problems,
                config,
                hasProblems: problems && problems.length > 0
            }
        })
        
        const detectionResults = await Promise.all(detectionPromises)
        
        // è¿‡æ»¤å‡ºæœ‰é—®é¢˜çš„ç±»åˆ«
        const categoriesWithProblems = detectionResults.filter(result => result.hasProblems)
        
        if (categoriesWithProblems.length === 0) {
            console.log('âœ… æ‰¹é‡æ£€æµ‹å®Œæˆï¼Œæœªå‘ç°é—®é¢˜')
            return { hasProblems: false, results: [] }
        }
        
        console.log(`ğŸš¨ å‘ç°${categoriesWithProblems.length}ä¸ªé—®é¢˜ç±»åˆ«`)
        
        // ğŸ”´ æŒ‰ä¼˜å…ˆçº§æ’åºå¹¶å¤„ç†
        categoriesWithProblems.sort((a, b) => {
            const priorityOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 }
            return priorityOrder[a.config.priority] - priorityOrder[b.config.priority]
        })
        
        // ä¸²è¡Œå¤„ç†é«˜ä¼˜å…ˆçº§é—®é¢˜ï¼Œå¹¶è¡Œå¤„ç†åŒä¼˜å…ˆçº§é—®é¢˜
        for (const group of this.groupByPriority(categoriesWithProblems)) {
            const groupResults = await Promise.all(
                group.map(async category => {
                    const processor = eval(category.config.processor)
                    const result = await processor.process(category.problems)
                    
                    return {
                        category: category.category,
                        result,
                        priority: category.config.priority
                    }
                })
            )
            
            processingResults.push(...groupResults)
        }
        
        return {
            hasProblems: true,
            totalCategories: categoriesWithProblems.length,
            results: processingResults,
            summary: this.generateProcessingSummary(processingResults)
        }
    }
    
    static groupByPriority(categories) {
        const groups = []
        let currentPriority = null
        let currentGroup = []
        
        for (const category of categories) {
            if (category.config.priority !== currentPriority) {
                if (currentGroup.length > 0) {
                    groups.push(currentGroup)
                }
                currentGroup = [category]
                currentPriority = category.config.priority
            } else {
                currentGroup.push(category)
            }
        }
        
        if (currentGroup.length > 0) {
            groups.push(currentGroup)
        }
        
        return groups
    }
    
    static generateProcessingSummary(results) {
        const summary = {
            totalCategories: results.length,
            successfulFixes: 0,
            failedFixes: 0,
            timeSaved: 0
        }
        
        results.forEach(result => {
            if (result.result.success) {
                summary.successfulFixes++
                summary.timeSaved += result.result.timeSaved || 0
            } else {
                summary.failedFixes++
            }
        })
        
        console.log(`ğŸ“Š æ‰¹é‡å¤„ç†æ‘˜è¦:`)
        console.log(`  å¤„ç†ç±»åˆ«: ${summary.totalCategories}`)
        console.log(`  æˆåŠŸä¿®å¤: ${summary.successfulFixes}`)
        console.log(`  ä¿®å¤å¤±è´¥: ${summary.failedFixes}`)
        console.log(`  èŠ‚çœæ—¶é—´: ${summary.timeSaved}ms`)
        
        return summary
    }
}
```

---

**è§„åˆ™åˆ›å»ºæ—¶é—´**: $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")  
**æœ€åæ›´æ–°æ—¶é—´**: $(Get-Date -Format "yyyyå¹´MMæœˆddæ—¥")  
**æ›´æ–°å†…å®¹**: å®Œå–„æ ¸å¿ƒé—®é¢˜é¢„é˜²è§„åˆ™ï¼Œè¡¥å……æ‰¹é‡å¤„ç†å¼•æ“ï¼Œç¡®ä¿æ–‡æ¡£å®Œæ•´æ€§  
**é€‚ç”¨èŒƒå›´**: æ‰€æœ‰éœ€è¦é—®é¢˜é¢„é˜²çš„å¼€å‘åœºæ™¯  
**ç»´æŠ¤çŠ¶æ€**: âœ… å·²å®Œå–„ - æ‰€æœ‰é¢„é˜²è§„åˆ™å·²è¡¥å……å®Œæ•´


