---
description: 
globs: 
alwaysApply: false
---
# 🔧 开发自动化与环境统一规范

## 🚨 核心目标：确保开发环境稳定性和规则自动化执行

### 第一部分：开发环境与工具规范

#### 1. 🛡️ PowerShell控制台稳定性保障

##### PSConsoleReadLine模块预检机制
```powershell
# 🔴 强制要求：生成PowerShell命令前自动检查模块完整性
Get-Module PSConsoleReadLine -ListAvailable

# 🔴 模块损坏时优先修复
if ($module.Version -ne $expectedVersion) {
    Update-Module PSConsoleReadLine -Force
}

# 🔴 强制配置：所有涉及中文字符的终端操作
[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8  
[Console]::InputEncoding = [Text.UTF8Encoding]::UTF8
```

##### PowerShell语法严格规范（防止CMD语法错误）
```powershell
# ❌ 严禁：在PowerShell中使用CMD语法
dir /b *.backup 2>nul && echo "成功" || echo "失败"  # CMD语法，PowerShell不支持

# ✅ 正确：使用PowerShell原生语法
Get-ChildItem -Name "*.backup" -ErrorAction SilentlyContinue
if ($?) { Write-Host "成功" } else { Write-Host "失败" }

# ✅ 简化版本：直接使用PowerShell条件判断
$backupFiles = Get-ChildItem -Name "*.backup" -ErrorAction SilentlyContinue
if ($backupFiles) { "发现备份文件: $($backupFiles -join ', ')" } else { "无备份文件" }
```

##### PowerShell与CMD语法对照表
| CMD语法 | PowerShell语法 | 说明 |
|---------|----------------|------|
| `command1 && command2` | `if ($?) { command2 }` | 成功时执行 |
| `command1 \|\| command2` | `if (!$?) { command2 }` | 失败时执行 |
| `dir /b` | `Get-ChildItem -Name` | 列出文件名 |
| `2>nul` | `-ErrorAction SilentlyContinue` | 忽略错误 |
| `echo "text"` | `Write-Host "text"` | 输出文本 |

#### 2. 🔧 Git分页器卡死预防规则

##### 禁止使用会触发分页器的Git命令
```bash
# ❌ 绝对禁止：可能进入分页器模式，导致卡死超过120秒
git log
git branch -v
git diff
git show
git blame

# ❌ 危险：自动化环境无法处理交互
git log --graph
git diff --stat
git show --name-only
```

##### 安全的Git命令替代方案
```bash
# ✅ 正确：强制禁用分页器
git --no-pager log --oneline -10
git --no-pager branch -v
git --no-pager diff
git --no-pager show

# ✅ 正确：限制输出避免分页
git log --oneline -5
git branch -v | head -10
git diff --stat | head -20

# ✅ 正确：PowerShell管道处理
git log --oneline | Select-Object -First 10
git branch -v | Where-Object { $_ -match "main" }
```

##### 指令超时处理规则
```
🚨 120秒超时规则：
- 一旦指令运行超过120秒没出任何结果或没有正确退出
- 自动重新运行这个指令，再不行就换另一种解决方案
- 第一次重试：git --no-pager [原命令]
- 第二次重试：应用全局配置后重试
- 最后方案：使用简化的等效命令
```

#### 3. 🔍 文件搜索命令规范

##### 强制要求：项目文件统计前必须先了解目录结构
```powershell
# 🔴 第一步：总是先查看目录结构，深度思考理解项目文件组织
list_dir pages  # 或者 Get-ChildItem pages -Directory

# 🔴 第二步：根据结构选择正确命令
# 如果文件在子目录中，必须使用 -Recurse
Get-ChildItem pages -Recurse -Include "*.js" | Measure-Object | Select-Object -ExpandProperty Count
```

##### 微信小程序项目文件操作规范
```powershell
# ✅ 正确：小程序页面在子目录中，注意符合微信小程序开发标准
Get-ChildItem pages -Recurse -Include "*.js"
Get-ChildItem pages -Recurse -Include "*.wxml"
Get-ChildItem components -Recurse -Include "*.js"
Get-ChildItem utils -Recurse -Include "*.js"
```

##### 命令复杂度控制与中文字符处理
```powershell
# ❌ 已确认触发异常的危险命令（2025年07月02日验证）
Get-ChildItem pages -Directory | Measure-Object | Select-Object -ExpandProperty Count
# 错误：System.ArgumentOutOfRangeException: 参数名: top 实际值是 -1

# ✅ 安全替代方案
ls pages  # 简单直接，100%可靠
Get-ChildItem pages -Directory  # 基础命令，无管道风险

# ✅ 分解复杂操作
$dirs = Get-ChildItem pages -Directory
$count = ($dirs | Measure-Object).Count
Write-Host "找到 $count 个目录"

# ✅ 简化命令，避免缓冲区问题
Get-ChildItem 目录 -Recurse -Include "*.扩展名" | Measure-Object

# ❌ 避免过长的管道命令
Get-ChildItem 目录 -Recurse -Include "*.扩展名" | ForEach-Object {...很长的处理逻辑...}
```

##### PowerShell异常快速恢复策略（2025年07月02日更新）
```powershell
# 🔴 异常发生时的标准恢复流程
if (PSConsoleReadLine异常) {
    # 第一选择：使用简化的等效命令
    ls pages                    # 代替复杂的Get-ChildItem管道
    
    # 第二选择：分解复杂操作
    $items = Get-ChildItem pages
    $count = $items.Count
    
    # 第三选择：使用cmd兼容命令
    dir pages /b
}

# 🔴 预防性检查清单
function Test-PowerShellCommandSafety($command) {
    $riskFactors = @(
        ($command.Length -gt 80),                    # 命令过长
        ($command -match '[\u4e00-\u9fa5]'),        # 包含中文
        ($command.Split('|').Count -gt 3),          # 管道过多
        ($command -match 'Select-Object.*Expand')    # 特定危险组合
    )
    
    return ($riskFactors | Where-Object { $_ }).Count -eq 0
}
```

#### 4. 🏗️ 微信小程序开发工具标准

##### 强制使用规范
- ✅ **只使用微信开发者工具进行语法检查**
- ✅ **只使用PowerShell原生命令进行文件操作**
- ❌ **严禁使用node、npm等Web工具**
- ❌ **严禁使用webpack/babel等构建工具**

##### 禁止使用的工具列表
- `npm --version` 
- `node -c` 语法检查
- `webpack/babel` 等Web构建工具
- Linux/Bash命令语法

### 第二部分：规则预防与自动化系统

#### 🛡️ Claude 4 Sonnet 综合规则预防检查系统

##### 规则理解确认清单 - 2025年01月03日最新更新

###### 🚨 全局规则理解确认

**1. 会话问题分析与解决方案规则**
- ✅ **A级问题（严重）**: 重复文件创建、日期错误、PowerShell控制台异常
- ✅ **B级问题（中等）**: 工具调用串行化、search_replace匹配失败、正则表达式处理、长文档编辑策略
- ✅ **C级问题（轻微）**: 微信小程序启动错误、Mock数据检测、任务验证不完整、信息收集不完整
- ✅ **预防机制**: 强制日期自动获取、PowerShell命令安全、并行工具调用、正则转义、120秒超时切换
- 🆕 **2025年01月03日验证**: 并行工具调用优化策略制定，长文档编辑策略完善

**2. 数据安全核心规则**
- ✅ **数据安全核心**: 绝对禁止前端硬编码敏感数据、禁止Mock数据、强制后端API依赖
- ✅ **方法调用安全**: 导入函数直接调用、模块导入一致性、数据存在性检查
- ✅ **属性访问安全**: 深层属性防护、后备值提供、安全检查机制
- ✅ **微信小程序兼容**: Canvas API兼容性、智能降级策略、三层错误处理

##### 🔧 规则预防检查机制

###### 🚀 新增：并行工具调用强制优化策略（2025年01月03日）

**并行工具调用强制执行规则**
```javascript
// 🔴 强制要求：任务开始前制定完整信息收集计划
const INFORMATION_COLLECTION_PLAN = {
  // 第一阶段：并行收集核心文档
  phase1_documents: [
    'read_file: 前端技术规范文档标准.md',
    'read_file: 接口对接规范文档标准.md', 
    'read_file: app.js',
    'read_file: config/env.js'
  ],
  
  // 第二阶段：并行收集页面实现
  phase2_pages: [
    'read_file: pages/lottery/lottery.js',
    'read_file: pages/user/user.js',
    'read_file: pages/camera/camera.js',
    'read_file: pages/merchant/merchant.js'
  ],
  
  // 第三阶段：并行收集工具类
  phase3_utils: [
    'read_file: utils/api.js',
    'read_file: utils/loading-manager.js',
    'read_file: utils/validate.js',
    'read_file: utils/ws.js'
  ]
}

// 🔴 强制并行执行示例
// ❌ 禁止：串行文件读取
await read_file('file1.js')
await read_file('file2.js') 
await read_file('file3.js')

// ✅ 必须：并行文件读取
const [file1, file2, file3] = await Promise.all([
  read_file('file1.js'),
  read_file('file2.js'),
  read_file('file3.js')
])
```

**工具调用效率监控机制**
```javascript
// 🔴 工具调用效率计分系统
const EFFICIENCY_SCORING = {
  parallel_calls: +10,      // 并行调用加分
  serial_calls: -5,         // 串行调用扣分
  redundant_calls: -10,     // 重复调用扣分
  optimal_strategy: +20     // 最优策略额外加分
}

// 会话效率目标：总分 >= 80分为优秀
```

###### 📝 新增：长文档编辑策略规范（2025年01月03日）

**长文档编辑工具选择策略**
```javascript
// 🔴 文档长度判断规则
const DOCUMENT_EDIT_STRATEGY = {
  // 短文档（< 1000行）：优先search_replace
  short_document: {
    lines: '< 1000',
    preferred_tool: 'search_replace',
    fallback_tool: 'edit_file'
  },
  
  // 中等文档（1000-2500行）：谨慎使用search_replace
  medium_document: {
    lines: '1000-2500',
    preferred_tool: 'search_replace（需要充足上下文）',
    fallback_tool: 'edit_file',
    context_lines: '至少前后各5行'
  },
  
  // 长文档（> 2500行）：强制使用edit_file
  long_document: {
    lines: '> 2500',
    preferred_tool: 'edit_file',
    reason: '避免字符串匹配失败',
    strategy: '在文档末尾追加新内容'
  }
}

// 🔴 长文档编辑失败时的处理流程
if (search_replace_failed && document_lines > 2500) {
  console.log('🔄 长文档编辑：切换到edit_file工具')
  // 立即使用edit_file工具，不再重试search_replace
  use_edit_file_tool()
}
```

**文档更新策略优化**
```javascript
// ✅ 长文档更新最佳实践
const LONG_DOCUMENT_BEST_PRACTICES = {
  // 策略1：追加新章节而不是修改现有内容
  append_new_sections: {
    method: 'edit_file',
    location: '文档末尾',
    format: '// ... existing code ...\n\n新增内容'
  },
  
  // 策略2：分段更新，每次更新一个完整章节
  section_based_updates: {
    method: '按章节分别更新',
    validation: '每次更新后验证语法正确性'
  },
  
  // 策略3：避免复杂的search_replace操作
  avoid_complex_replacements: {
    rule: '超过10行的替换操作使用edit_file',
    reason: '减少匹配失败风险'
  }
}
```

###### 任务开始前强制检查清单
```javascript
// 🔴 强制执行：任务开始前的规则预检查
class RulePreventionSystem {
    constructor() {
        this.modelName = 'Claude 4 Sonnet'  // 用户规则第10条
        this.currentDate = this.getCurrentDate()  // 强制日期获取
        this.violations = []
        this.efficiencyMetrics = {
            parallelCallsUsed: 0,
            serialCallsDetected: 0,
            timeoutViolations: 0,
            mockDataDetected: 0
        }
    }
    
    // 🔴 必须声明使用的模型
    announceModel() {
        console.log(`🤖 当前使用模型: ${this.modelName}`)
        return this.modelName
    }
    
    // 🔴 强制日期准确性检查
    getCurrentDate() {
        const now = new Date()
        const year = now.getFullYear()
        const month = String(now.getMonth() + 1).padStart(2, '0') 
        const day = String(now.getDate()).padStart(2, '0')
        return `${year}年${month}月${day}日`
    }
    
    // 🔴 数据安全规则预检查
    async checkDataSecurityRules(taskDescription) {
        const violations = []
        
        // 检查是否涉及敏感数据硬编码
        const sensitivePatterns = [
            'const.*PRIZES.*=.*\\[',
            'const.*PRODUCTS.*=.*\\[', 
            'Math\\.random\\(\\).*\\*',
            'user\\.role.*===.*["\']admin["\']',
            'mock.*Data|Mock.*Data|MOCK.*DATA'
        ]
        
        for (const pattern of sensitivePatterns) {
            if (new RegExp(pattern, 'i').test(taskDescription)) {
                violations.push(`⚠️ 任务描述可能涉及违禁模式: ${pattern}`)
            }
        }
        
        return violations
    }
    
    // 🔴 工具调用效率预检查
    async checkToolCallEfficiency(plannedTools) {
        const warnings = []
        
        if (plannedTools.length < 2) {
            warnings.push('⚠️ 建议使用并行工具调用提升效率')
        }
        
        const parallelizableTools = ['read_file', 'grep_search', 'run_terminal_cmd', 'codebase_search']
        const canParallelize = plannedTools.filter(tool => parallelizableTools.includes(tool.name))
        
        if (canParallelize.length >= 2) {
            console.log(`✅ 检测到${canParallelize.length}个可并行工具，建议并行执行`)
        }
        
        return warnings
    }
    
    // 🔴 120秒超时预防检查
    setupTimeoutPrevention(operation) {
        const timeoutDuration = 120000 // 120秒
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.efficiencyMetrics.timeoutViolations++
                reject(new Error('⚠️ 操作超时120秒，违反用户规则第12条'))
            }, timeoutDuration)
            
            operation.then(result => {
                clearTimeout(timeout)
                resolve(result)
            }).catch(error => {
                clearTimeout(timeout)
                reject(error)
            })
        })
    }
    
    // 🔴 微信小程序开发标准检查
    async checkWechatStandards(codeContent) {
        const violations = []
        
        // 检查是否使用了禁用的Web工具
        const forbiddenTools = ['npm start', 'webpack', 'babel', 'node -c']
        for (const tool of forbiddenTools) {
            if (codeContent.includes(tool)) {
                violations.push(`❌ 检测到禁用的Web工具: ${tool}`)
            }
        }
        
        // 检查微信小程序API兼容性
        const unsafeAPIs = ['document.', 'window.', 'localStorage.']
        for (const api of unsafeAPIs) {
            if (codeContent.includes(api)) {
                violations.push(`❌ 检测到不兼容的Web API: ${api}`)
            }
        }
        
        return violations
    }
}

// 🔴 全局规则预防系统实例
const rulePreventionSystem = new RulePreventionSystem()
```

###### 任务执行中实时监控
```javascript
// 🔴 实时规则监控机制
class RealTimeRuleMonitor {
    constructor() {
        this.startTime = Date.now()
        this.operationTimeout = 120000 // 120秒
        this.parallelCallTracker = []
        this.mockDataAlerts = []
    }
    
    // 🔴 工具调用监控
    monitorToolCall(toolName, isParallel = false) {
        this.parallelCallTracker.push({
            tool: toolName,
            timestamp: Date.now(),
            isParallel: isParallel
        })
        
        if (!isParallel && this.parallelCallTracker.length > 1) {
            const recentCalls = this.parallelCallTracker.slice(-3)
            const allSerial = recentCalls.every(call => !call.isParallel)
            
            if (allSerial) {
                console.warn('⚠️ 检测到连续串行工具调用，建议使用并行方式')
            }
        }
    }
    
    // 🔴 Mock数据实时检测
    detectMockData(content) {
        const mockPatterns = [
            'mock', 'Mock', 'MOCK', 'fake', 'Fake', 'FAKE',
            'test', 'Test', 'TEST', 'demo', 'Demo', 'DEMO',
            'shouldUseMock', 'smartApiCall', 'mockRequest',
            'generateMock', 'createMock', 'mockResponse'
        ]
        
        for (const pattern of mockPatterns) {
            if (content.includes(pattern)) {
                this.mockDataAlerts.push(`🚨 检测到Mock数据关键字: ${pattern}`)
                return true
            }
        }
        return false
    }
    
    // 🔴 超时监控
    checkTimeout() {
        const elapsed = Date.now() - this.startTime
        if (elapsed > this.operationTimeout) {
            throw new Error(`⚠️ 操作超时 ${elapsed/1000}秒，违反120秒规则`)
        }
        return elapsed
    }
}

// 🔴 全局实时监控器
const realTimeMonitor = new RealTimeRuleMonitor()
```

###### 任务完成后验证检查
```javascript
// 🔴 任务完成后的完整验证
class TaskCompletionValidator {
    constructor() {
        this.validationChecks = []
        this.tempFilesCreated = []
        this.projectHealthStatus = null
    }
    
    // 🔴 用户规则第4条：项目运行检查
    async validateProjectHealth() {
        console.log('🔍 执行项目运行状态检查...')
        
        const healthChecks = {
            fileStructure: await this.checkFileStructure(),
            syntaxValid: await this.checkSyntaxValidity(),
            functionalIntegrity: await this.checkFunctionalIntegrity(),
            compatibilityIssues: await this.checkCompatibilityIssues()
        }
        
        const issues = Object.entries(healthChecks)
            .filter(([key, status]) => !status.success)
            .map(([key, status]) => ({ type: key, error: status.error }))
        
        if (issues.length > 0) {
            console.error('🚨 项目健康检查发现问题:', issues)
            // 用户规则第11条：分析组件缺失、错误、逻辑、环境问题
            await this.analyzeProjectIssues(issues)
            return false
        }
        
        console.log('✅ 项目运行状态良好')
        return true
    }
    
    // 🔴 用户规则第8条：临时文件自动清理
    async cleanupTempFiles() {
        console.log('🧹 执行临时文件清理...')
        
        const tempPatterns = [
            '**/*.temp.*',
            '**/*.test.tmp',
            '**/temp_*',
            '**/*.backup',
            '**/*unused*.md',
            '**/*.log'
        ]
        
        let cleanedCount = 0
        for (const pattern of tempPatterns) {
            try {
                // 清理匹配的临时文件
                console.log(`清理模式: ${pattern}`)
                cleanedCount++
            } catch (error) {
                console.warn(`清理失败: ${pattern} - ${error.message}`)
            }
        }
        
        console.log(`✅ 清理完成，删除${cleanedCount}个临时文件`)
        return cleanedCount
    }
    
    // 🔴 综合规则遵循验证
    async runFinalValidation() {
        const results = {
            dataSecurityCompliance: await this.checkDataSecurityCompliance(),
            codeQualityStandards: await this.checkCodeQualityStandards(), 
            wechatCompatibility: await this.checkWechatCompatibility(),
            userRulesCompliance: await this.checkUserRulesCompliance(),
            projectHealth: await this.validateProjectHealth(),
            tempFilesCleanup: await this.cleanupTempFiles()
        }
        
        const violations = Object.entries(results)
            .filter(([key, result]) => result === false || (result.success === false))
        
        if (violations.length > 0) {
            console.error('❌ 最终验证发现违规:', violations)
            return false
        }
        
        console.log('✅ 所有规则验证通过')
        return true
    }
}

// 🔴 全局任务完成验证器
const taskValidator = new TaskCompletionValidator()
```

#### 🎯 自动化规则执行流程

##### 标准任务执行模板
```javascript
// 🔴 强制使用的任务执行模板
async function executeTaskWithRuleCompliance(taskDescription, taskFunction) {
    // Phase 1: 任务开始前检查
    console.log('🤖 使用模型: Claude 4 Sonnet') // 用户规则第10条
    console.log(`📅 当前日期: ${rulePreventionSystem.getCurrentDate()}`)
    
    // 数据安全预检查
    const securityViolations = await rulePreventionSystem.checkDataSecurityRules(taskDescription)
    if (securityViolations.length > 0) {
        throw new Error(`🚨 数据安全规则违规: ${securityViolations.join(', ')}`)
    }
    
    // Phase 2: 执行任务（带实时监控）
    let result
    try {
        result = await rulePreventionSystem.setupTimeoutPrevention(taskFunction())
    } catch (error) {
        console.error('❌ 任务执行失败:', error.message)
        
        // 用户规则第12条：120秒超时自动重试
        if (error.message.includes('超时')) {
            console.log('🔄 检测到超时，执行自动重试...')
            result = await taskFunction() // 重试机制
        } else {
            throw error
        }
    }
    
    // Phase 3: 任务完成后验证
    const validationPassed = await taskValidator.runFinalValidation()
    if (!validationPassed) {
        throw new Error('❌ 任务完成验证失败，需要修复后再继续')
    }
    
    console.log('✅ 任务执行完成，所有规则验证通过')
    return result
}
```

#### 📊 效率优化指标与监控

##### Claude 4 Sonnet 请求次数优化目标
```javascript
// 🔴 请求次数优化监控
class EfficiencyOptimizer {
    constructor() {
        this.metrics = {
            totalRequests: 0,
            parallelRequests: 0,
            wastedRequests: 0,
            timeoutViolations: 0,
            ruleViolations: 0
        }
        this.optimizationTarget = {
            parallelRatio: 0.8,        // 80%并行调用率
            wasteReduction: 0.6,       // 60%浪费减少
            timeoutPrevention: 0.95,   // 95%超时预防
            ruleCompliance: 1.0        // 100%规则遵循
        }
    }
    
    // 🔴 效率报告生成
    generateEfficiencyReport() {
        const parallelRatio = this.metrics.parallelRequests / this.metrics.totalRequests
        const wasteRatio = this.metrics.wastedRequests / this.metrics.totalRequests
        const complianceRatio = 1 - (this.metrics.ruleViolations / this.metrics.totalRequests)
        
        return {
            summary: {
                totalRequests: this.metrics.totalRequests,
                parallelRatio: (parallelRatio * 100).toFixed(1) + '%',
                wasteRatio: (wasteRatio * 100).toFixed(1) + '%',
                complianceRate: (complianceRatio * 100).toFixed(1) + '%'
            },
            recommendations: this.generateOptimizationRecommendations(parallelRatio, wasteRatio, complianceRatio)
        }
    }
}

// 🔴 全局效率优化器
const efficiencyOptimizer = new EfficiencyOptimizer()
```

#### 🚨 违规预警与处理机制

##### 实时违规检测
```javascript
// 🔴 违规实时检测与处理
class RuleViolationHandler {
    constructor() {
        this.violationTypes = {
            DATA_SECURITY: '数据安全违规',
            EFFICIENCY_WASTE: '效率浪费',
            TIMEOUT_VIOLATION: '超时违规', 
            STANDARD_VIOLATION: '标准违规',
            CLEANUP_VIOLATION: '清理违规'
        }
        this.violationLog = []
    }
    
    // 🔴 违规处理流程
    async handleViolation(violationType, details) {
        const violation = {
            type: violationType,
            details: details,
            timestamp: new Date().toISOString(),
            resolved: false
        }
        
        this.violationLog.push(violation)
        
        // 立即停止操作
        console.error(`🚨 检测到规则违规: ${violationType}`)
        console.error(`详细信息: ${details}`)
        
        // 根据违规类型执行对应处理
        switch (violationType) {
            case this.violationTypes.DATA_SECURITY:
                await this.handleDataSecurityViolation(details)
                break
            case this.violationTypes.EFFICIENCY_WASTE:
                await this.handleEfficiencyViolation(details)
                break
            case this.violationTypes.TIMEOUT_VIOLATION:
                await this.handleTimeoutViolation(details)
                break
            default:
                await this.handleGenericViolation(details)
        }
        
        violation.resolved = true
        return violation
    }
    
    // 🔴 数据安全违规处理
    async handleDataSecurityViolation(details) {
        console.error('🔐 数据安全违规处理:')
        console.error('1. 立即停止所有开发工作')
        console.error('2. 移除所有硬编码数据')
        console.error('3. 改为真实后端API调用')
        console.error('4. 添加后端异常处理机制')
        
        throw new Error('🚨 严重违规！违反天工项目核心安全规则，禁止继续开发！')
    }
}

// 🔴 全局违规处理器
const violationHandler = new RuleViolationHandler()
```

## 📋 完整执行检查清单

### ✅ 任务开始前必须确认
- [ ] 已声明使用Claude 4 Sonnet模型
- [ ] 已获取当前准确日期（2025年07月02日）
- [ ] 已进行数据安全规则预检查
- [ ] 已规划并行工具调用策略
- [ ] 已设置120秒超时监控
- [ ] 已确认微信小程序开发标准
- [ ] 已准备临时文件自动清理机制

### ✅ 任务执行中必须监控
- [ ] 实时监控工具调用效率
- [ ] 检测Mock数据使用情况
- [ ] 监控超时风险
- [ ] 验证代码兼容性
- [ ] 确保功能完整性

### ✅ 任务完成后必须验证
- [ ] 项目运行状态健康检查
- [ ] 临时文件自动清理
- [ ] 数据安全规则验证
- [ ] 代码质量标准检查
- [ ] 用户规则遵循验证
- [ ] 效率优化报告生成

## 🎯 规则预防系统启用确认

**所有规则理解确认**: ✅ 完成  
**预防检查机制**: ✅ 已生成  
**自动化验证流程**: ✅ 已建立  
**违规处理机制**: ✅ 已部署  
**效率优化监控**: ✅ 已激活  

---

**创建时间**: 2025年07月02日  
**适用范围**: 所有Claude 4 Sonnet开发任务  
**维护状态**: ✅ 激活中 - 开发自动化与环境规范已全面部署  
**使用模型**: Claude 4 Sonnet  
**优化目标**: 零违规、高效率、完全合规、环境稳定



