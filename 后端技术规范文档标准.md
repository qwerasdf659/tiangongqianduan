# 🚀 后端技术规范文档 - 编写标准与准则

> **基于Node.js的后端开发技术规范** - 从"前端2号"文档提炼的专业标准

## 📋 一、文档定位与标准

### 1.1 文档定位
- **唯一受众**：后端开发工程师、DevOps工程师
- **核心职责**：Node.js后端服务开发规范
- **技术边界**：仅涵盖后端技术栈，不包含前端UI逻辑
- **内容深度**：深入后端专业领域，提供生产级解决方案

### 1.2 文档结构标准
```
# Node.js后端技术规范
├── 🏗️ 服务架构规范
├── 📁 项目结构规范
├── 🔌 API设计规范
├── 🗄️ 数据访问规范
├── 🔐 安全防护规范
├── 🔍 日志监控规范
├── ⚡ 性能优化规范
├── 🧪 测试规范
├── 🚀 部署运维规范
└── 📊 监控告警规范
```

## 🏗️ 二、服务架构规范

### 2.1 微服务架构设计
```javascript
// 🔴 服务分层架构标准
const SERVICE_LAYERS = {
  // 1. 接入层 (Gateway Layer)
  gateway: {
    purpose: 'API网关、路由分发、认证鉴权',
    technologies: ['Express.js', 'Koa.js', 'Fastify'],
    responsibilities: [
      'HTTP请求路由',
      'JWT token验证',
      '请求限流',
      '跨域处理',
      '请求日志记录'
    ]
  },
  
  // 2. 业务层 (Business Layer)
  business: {
    purpose: '业务逻辑处理、数据验证',
    technologies: ['Service Classes', 'Business Logic'],
    responsibilities: [
      '业务规则实现',
      '数据验证',
      '业务流程控制',
      '第三方服务集成'
    ]
  },
  
  // 3. 数据层 (Data Layer)
  data: {
    purpose: '数据访问、缓存管理',
    technologies: ['MySQL', 'Redis', 'Sequelize'],
    responsibilities: [
      '数据库操作',
      '缓存管理',
      '数据持久化',
      '事务处理'
    ]
  },
  
  // 4. 外部服务层 (External Layer)
  external: {
    purpose: '外部服务集成',
    technologies: ['HTTP Client', 'WebSocket', 'Message Queue'],
    responsibilities: [
      '第三方API调用',
      '消息队列处理',
      '文件存储服务',
      '实时通信服务'
    ]
  }
}
```

### 2.2 项目结构规范
```
// 🔴 标准Node.js项目结构
restaurant-lottery-backend/
├── src/
│   ├── controllers/          // 🔴 控制器层 - 请求处理
│   │   ├── auth.controller.js
│   │   ├── lottery.controller.js
│   │   └── user.controller.js
│   ├── services/            // 🔴 业务层 - 业务逻辑
│   │   ├── auth.service.js
│   │   ├── lottery.service.js
│   │   └── user.service.js
│   ├── models/              // 🔴 数据模型层
│   │   ├── User.js
│   │   ├── Lottery.js
│   │   └── Product.js
│   ├── middleware/          // 🔴 中间件
│   │   ├── auth.middleware.js
│   │   ├── validation.middleware.js
│   │   └── ratelimit.middleware.js
│   ├── routes/              // 🔴 路由定义
│   │   ├── auth.routes.js
│   │   ├── lottery.routes.js
│   │   └── user.routes.js
│   ├── utils/               // 🔴 工具函数
│   │   ├── logger.js
│   │   ├── redis.js
│   │   └── sms.js
│   ├── config/              // 🔴 配置文件
│   │   ├── database.js
│   │   ├── redis.js
│   │   └── environment.js
│   └── app.js               // 🔴 应用入口
├── tests/                   // 🔴 测试文件
├── docs/                    // 🔴 API文档
├── docker/                  // 🔴 容器配置
├── scripts/                 // 🔴 部署脚本
├── package.json
└── README.md
```

## 🔌 三、API设计规范

### 3.1 RESTful API设计标准
```javascript
// 🔴 API路由设计规范
const API_DESIGN_STANDARDS = {
  // 1. 资源命名规范
  naming: {
    pattern: 'kebab-case',
    examples: {
      users: '/api/users',
      userProfiles: '/api/user-profiles',
      lotteryRecords: '/api/lottery-records'
    }
  },
  
  // 2. HTTP方法使用规范
  methods: {
    GET: '获取资源',
    POST: '创建资源',
    PUT: '完整更新资源',
    PATCH: '部分更新资源',
    DELETE: '删除资源'
  },
  
  // 3. 状态码使用规范
  statusCodes: {
    200: '请求成功',
    201: '创建成功',
    400: '请求参数错误',
    401: '未授权',
    403: '权限不足',
    404: '资源不存在',
    500: '服务器内部错误'
  }
}

// ✅ 标准控制器实现
class LotteryController {
  constructor() {
    this.lotteryService = new LotteryService()
  }
  
  /**
   * 🔴 获取抽奖配置
   * GET /api/lottery/config
   */
  async getConfig(req, res) {
    try {
      const config = await this.lotteryService.getConfig()
      
      res.status(200).json({
        code: 0,
        message: '获取成功',
        data: config,
        timestamp: new Date().toISOString()
      })
    } catch (error) {
      this.handleError(res, error)
    }
  }
  
  /**
   * 🔴 执行抽奖
   * POST /api/lottery/draw
   */
  async draw(req, res) {
    try {
      // 1. 参数验证
      const { userId, costPoints } = req.body
      if (!userId || !costPoints) {
        return res.status(400).json({
          code: 400,
          message: '参数不完整'
        })
      }
      
      // 2. 业务逻辑处理
      const result = await this.lotteryService.draw(userId, costPoints)
      
      // 3. 返回结果
      res.status(200).json({
        code: 0,
        message: '抽奖成功',
        data: result
      })
      
    } catch (error) {
      this.handleError(res, error)
    }
  }
  
  /**
   * 🔴 统一错误处理
   */
  handleError(res, error) {
    console.error('Controller Error:', error)
    
    // 根据错误类型返回不同状态码
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        code: 400,
        message: error.message
      })
    }
    
    if (error.name === 'UnauthorizedError') {
      return res.status(401).json({
        code: 401,
        message: '认证失败'
      })
    }
    
    res.status(500).json({
      code: 500,
      message: '服务器内部错误'
    })
  }
}
```

### 3.2 数据验证中间件
```javascript
// 🔴 请求数据验证标准
const Joi = require('joi')

const validationSchemas = {
  // 用户登录验证
  login: Joi.object({
    mobile: Joi.string()
      .pattern(/^1[3-9]\d{9}$/)
      .required()
      .messages({
        'string.pattern.base': '手机号格式不正确'
      }),
    code: Joi.string()
      .length(6)
      .pattern(/^\d{6}$/)
      .required()
      .messages({
        'string.length': '验证码必须是6位数字'
      })
  }),
  
  // 抽奖请求验证
  lottery: Joi.object({
    userId: Joi.number().integer().positive().required(),
    costPoints: Joi.number().integer().min(1).required()
  })
}

// ✅ 验证中间件实现
const validateRequest = (schema) => {
  return (req, res, next) => {
    const { error } = schema.validate(req.body)
    if (error) {
      return res.status(400).json({
        code: 400,
        message: error.details[0].message
      })
    }
    next()
  }
}

// 使用方式
router.post('/login', 
  validateRequest(validationSchemas.login),
  authController.login
)
```

## 🗄️ 四、数据访问规范

### 4.1 数据库连接管理
```javascript
// 🔴 数据库连接池配置
const { Sequelize } = require('sequelize')

class DatabaseManager {
  constructor() {
    this.sequelize = new Sequelize({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      username: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      dialect: 'mysql',
      
      // 🔴 连接池配置
      pool: {
        max: 10,          // 最大连接数
        min: 0,           // 最小连接数
        acquire: 30000,   // 获取连接超时时间
        idle: 10000       // 连接空闲时间
      },
      
      // 🔴 日志配置
      logging: process.env.NODE_ENV === 'development' ? console.log : false,
      
      // 🔴 性能优化配置
      define: {
        freezeTableName: true,  // 禁用表名复数形式
        timestamps: true,       // 启用时间戳
        underscored: true,      // 使用下划线命名
        paranoid: true          // 启用软删除
      }
    })
  }
  
  // 🔴 数据库连接初始化
  async initialize() {
    try {
      await this.sequelize.authenticate()
      console.log('✅ 数据库连接成功')
      
      // 同步数据库表结构
      if (process.env.NODE_ENV === 'development') {
        await this.sequelize.sync({ alter: true })
      }
    } catch (error) {
      console.error('❌ 数据库连接失败:', error)
      process.exit(1)
    }
  }
  
  // 🔴 获取数据库实例
  getInstance() {
    return this.sequelize
  }
}
```

### 4.2 模型定义规范
```javascript
// 🔴 数据模型标准定义
const { DataTypes } = require('sequelize')

const User = sequelize.define('User', {
  // 🔴 主键字段
  user_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true,
    comment: '用户唯一标识'
  },
  
  // 🔴 业务字段
  mobile: {
    type: DataTypes.STRING(11),
    allowNull: false,
    unique: true,
    validate: {
      is: /^1[3-9]\d{9}$/,
      notEmpty: true
    },
    comment: '手机号'
  },
  
  nickname: {
    type: DataTypes.STRING(50),
    allowNull: true,
    defaultValue: '',
    comment: '用户昵称'
  },
  
  avatar: {
    type: DataTypes.STRING(255),
    allowNull: true,
    defaultValue: '',
    comment: '用户头像URL'
  },
  
  total_points: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0,
    validate: {
      min: 0
    },
    comment: '用户总积分'
  },
  
  // 🔴 状态字段
  status: {
    type: DataTypes.ENUM('active', 'inactive', 'banned'),
    allowNull: false,
    defaultValue: 'active',
    comment: '用户状态'
  },
  
  // 🔴 权限字段
  is_merchant: {
    type: DataTypes.BOOLEAN,
    allowNull: false,
    defaultValue: false,
    comment: '是否为商家'
  },
  
  // 🔴 微信相关字段
  wx_openid: {
    type: DataTypes.STRING(50),
    allowNull: true,
    unique: true,
    comment: '微信OpenID'
  }
}, {
  // 🔴 表配置
  tableName: 'users',
  timestamps: true,
  paranoid: true,
  
  // 🔴 索引配置
  indexes: [
    {
      unique: true,
      fields: ['mobile']
    },
    {
      unique: true,
      fields: ['wx_openid'],
      where: {
        wx_openid: {
          [Op.ne]: null
        }
      }
    },
    {
      fields: ['status', 'is_merchant']
    }
  ],
  
  // 🔴 模型钩子
  hooks: {
    beforeCreate: (user) => {
      // 创建前数据处理
      if (!user.nickname) {
        user.nickname = `用户${user.mobile.substr(-4)}`
      }
    }
  }
})

// 🔴 模型关联定义
User.hasMany(LotteryRecord, { foreignKey: 'user_id' })
User.hasMany(ExchangeRecord, { foreignKey: 'user_id' })
```

### 4.3 数据访问层服务
```javascript
// 🔴 数据访问层标准实现
class UserService {
  constructor() {
    this.model = User
  }
  
  /**
   * 🔴 创建用户 - 包含事务处理
   */
  async createUser(userData) {
    const transaction = await sequelize.transaction()
    
    try {
      // 1. 验证用户是否已存在
      const existingUser = await this.model.findOne({
        where: { mobile: userData.mobile }
      })
      
      if (existingUser) {
        throw new Error('用户已存在')
      }
      
      // 2. 创建用户
      const user = await this.model.create(userData, { transaction })
      
      // 3. 初始化用户积分记录
      await PointsHistory.create({
        user_id: user.user_id,
        points: 0,
        change_type: 'initial',
        description: '账户初始化'
      }, { transaction })
      
      await transaction.commit()
      return user
      
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
  
  /**
   * 🔴 更新用户积分 - 原子操作
   */
  async updateUserPoints(userId, pointsChange, description) {
    const transaction = await sequelize.transaction()
    
    try {
      // 1. 锁定用户记录
      const user = await this.model.findByPk(userId, {
        lock: transaction.LOCK.UPDATE,
        transaction
      })
      
      if (!user) {
        throw new Error('用户不存在')
      }
      
      // 2. 检查积分是否足够（扣减操作）
      if (pointsChange < 0 && user.total_points + pointsChange < 0) {
        throw new Error('积分不足')
      }
      
      // 3. 更新积分
      await user.update({
        total_points: user.total_points + pointsChange
      }, { transaction })
      
      // 4. 记录积分变动历史
      await PointsHistory.create({
        user_id: userId,
        points: pointsChange,
        change_type: pointsChange > 0 ? 'earn' : 'spend',
        description: description,
        balance_after: user.total_points + pointsChange
      }, { transaction })
      
      await transaction.commit()
      return user
      
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
  
  /**
   * 🔴 批量查询用户 - 分页和过滤
   */
  async findUsers(options = {}) {
    const {
      page = 1,
      limit = 20,
      status = 'active',
      isMerchant = null,
      search = null
    } = options
    
    const where = { status }
    
    // 商家筛选
    if (isMerchant !== null) {
      where.is_merchant = isMerchant
    }
    
    // 搜索条件
    if (search) {
      where[Op.or] = [
        { mobile: { [Op.like]: `%${search}%` } },
        { nickname: { [Op.like]: `%${search}%` } }
      ]
    }
    
    const result = await this.model.findAndCountAll({
      where,
      limit,
      offset: (page - 1) * limit,
      order: [['created_at', 'DESC']],
      attributes: { exclude: ['deleted_at'] }
    })
    
    return {
      users: result.rows,
      total: result.count,
      page,
      limit,
      totalPages: Math.ceil(result.count / limit)
    }
  }
}
```

## 🔐 五、安全防护规范

### 5.1 认证授权系统
```javascript
// 🔴 JWT认证中间件
const jwt = require('jsonwebtoken')
const rateLimit = require('express-rate-limit')

class AuthMiddleware {
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET
    this.jwtExpires = process.env.JWT_EXPIRES || '7d'
  }
  
  /**
   * 🔴 生成JWT Token
   */
  generateToken(payload) {
    return jwt.sign(payload, this.jwtSecret, {
      expiresIn: this.jwtExpires,
      issuer: 'restaurant-lottery-api',
      audience: 'restaurant-lottery-client'
    })
  }
  
  /**
   * 🔴 验证JWT Token
   */
  verifyToken(req, res, next) {
    const authHeader = req.headers.authorization
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        code: 401,
        message: '认证头格式错误'
      })
    }
    
    const token = authHeader.substring(7)
    
    try {
      const decoded = jwt.verify(token, this.jwtSecret)
      req.user = decoded
      next()
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          code: 401,
          message: 'Token已过期'
        })
      }
      
      return res.status(401).json({
        code: 401,
        message: 'Token验证失败'
      })
    }
  }
  
  /**
   * 🔴 权限验证中间件
   */
  requireMerchant(req, res, next) {
    if (!req.user.is_merchant) {
      return res.status(403).json({
        code: 403,
        message: '需要商家权限'
      })
    }
    next()
  }
}

// 🔴 请求频率限制
const createRateLimit = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    message: {
      code: 429,
      message
    },
    standardHeaders: true,
    legacyHeaders: false
  })
}

// 不同接口的限流配置
const rateLimiters = {
  // 登录接口：每分钟最多5次
  login: createRateLimit(60 * 1000, 5, '登录请求过于频繁'),
  
  // 发送验证码：每分钟最多3次
  sendCode: createRateLimit(60 * 1000, 3, '验证码发送过于频繁'),
  
  // 抽奖接口：每分钟最多10次
  lottery: createRateLimit(60 * 1000, 10, '抽奖请求过于频繁'),
  
  // 一般API：每分钟最多100次
  general: createRateLimit(60 * 1000, 100, '请求过于频繁')
}
```

### 5.2 数据加密与验证
```javascript
// 🔴 数据加密工具
const crypto = require('crypto')
const bcrypt = require('bcrypt')

class SecurityUtils {
  constructor() {
    this.algorithm = 'aes-256-gcm'
    this.secretKey = process.env.ENCRYPTION_KEY
  }
  
  /**
   * 🔴 敏感数据加密
   */
  encrypt(text) {
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipher(this.algorithm, this.secretKey)
    cipher.setAAD(Buffer.from('restaurant-lottery', 'utf8'))
    
    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const authTag = cipher.getAuthTag()
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    }
  }
  
  /**
   * 🔴 敏感数据解密
   */
  decrypt(encryptedData) {
    const { encrypted, iv, authTag } = encryptedData
    
    const decipher = crypto.createDecipher(this.algorithm, this.secretKey)
    decipher.setAAD(Buffer.from('restaurant-lottery', 'utf8'))
    decipher.setAuthTag(Buffer.from(authTag, 'hex'))
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
  
  /**
   * 🔴 密码哈希
   */
  async hashPassword(password) {
    const saltRounds = 12
    return await bcrypt.hash(password, saltRounds)
  }
  
  /**
   * 🔴 密码验证
   */
  async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash)
  }
  
  /**
   * 🔴 手机号脱敏
   */
  maskMobile(mobile) {
    if (!mobile || mobile.length !== 11) return mobile
    return mobile.substring(0, 3) + '****' + mobile.substring(7)
  }
}
```

## 🔍 六、日志监控规范

### 6.1 日志系统设计
```javascript
// 🔴 统一日志管理
const winston = require('winston')
const DailyRotateFile = require('winston-daily-rotate-file')

class Logger {
  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      
      transports: [
        // 🔴 控制台输出
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),
        
        // 🔴 文件输出 - 按日期轮转
        new DailyRotateFile({
          filename: 'logs/application-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          maxSize: '20m',
          maxFiles: '30d'
        }),
        
        // 🔴 错误日志单独记录
        new DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          level: 'error',
          maxSize: '20m',
          maxFiles: '90d'
        })
      ]
    })
  }
  
  /**
   * 🔴 API请求日志
   */
  logRequest(req, res, responseTime) {
    this.logger.info('API Request', {
      method: req.method,
      url: req.originalUrl,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      statusCode: res.statusCode,
      responseTime: `${responseTime}ms`,
      userId: req.user?.user_id,
      timestamp: new Date().toISOString()
    })
  }
  
  /**
   * 🔴 业务操作日志
   */
  logBusinessOperation(operation, data, userId = null) {
    this.logger.info('Business Operation', {
      operation,
      data,
      userId,
      timestamp: new Date().toISOString()
    })
  }
  
  /**
   * 🔴 错误日志
   */
  logError(error, context = {}) {
    this.logger.error('Application Error', {
      message: error.message,
      stack: error.stack,
      context,
      timestamp: new Date().toISOString()
    })
  }
}

// 🔴 请求日志中间件
const requestLogger = (req, res, next) => {
  const startTime = Date.now()
  
  res.on('finish', () => {
    const responseTime = Date.now() - startTime
    logger.logRequest(req, res, responseTime)
  })
  
  next()
}
```

### 6.2 性能监控
```javascript
// 🔴 性能监控中间件
const performanceMonitor = (req, res, next) => {
  const startTime = process.hrtime()
  const startMemory = process.memoryUsage()
  
  res.on('finish', () => {
    const [seconds, nanoseconds] = process.hrtime(startTime)
    const responseTime = seconds * 1000 + nanoseconds / 1000000
    const endMemory = process.memoryUsage()
    
    // 记录性能指标
    logger.info('Performance Metrics', {
      url: req.originalUrl,
      method: req.method,
      responseTime: `${responseTime.toFixed(2)}ms`,
      memoryUsage: {
        rss: endMemory.rss - startMemory.rss,
        heapUsed: endMemory.heapUsed - startMemory.heapUsed
      },
      timestamp: new Date().toISOString()
    })
    
    // 性能告警
    if (responseTime > 1000) {
      logger.warn('Slow API Response', {
        url: req.originalUrl,
        responseTime: `${responseTime.toFixed(2)}ms`
      })
    }
  })
  
  next()
}
```

## ⚡ 七、性能优化规范

### 7.1 数据库优化
```javascript
// 🔴 数据库查询优化策略
class DatabaseOptimization {
  
  /**
   * 🔴 查询优化 - 使用索引
   */
  async optimizedQuery(conditions) {
    // ✅ 使用索引字段查询
    return await User.findAll({
      where: {
        status: 'active',        // 有索引
        is_merchant: true        // 有联合索引
      },
      attributes: ['user_id', 'mobile', 'nickname'], // 只选择需要的字段
      limit: 50,
      offset: 0,
      order: [['created_at', 'DESC']]  // 使用索引排序
    })
  }
  
  /**
   * 🔴 批量操作优化
   */
  async batchUpdate(updates) {
    const transaction = await sequelize.transaction()
    
    try {
      // 使用批量更新而不是循环单个更新
      const promises = updates.map(update => 
        User.update(
          { total_points: update.points },
          { 
            where: { user_id: update.userId },
            transaction 
          }
        )
      )
      
      await Promise.all(promises)
      await transaction.commit()
      
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
  
  /**
   * 🔴 分页查询优化
   */
  async paginatedQuery(page, limit) {
    // 使用 offset 和 limit 进行分页
    const offset = (page - 1) * limit
    
    return await User.findAndCountAll({
      where: { status: 'active' },
      limit: Math.min(limit, 50), // 限制最大查询数量
      offset,
      order: [['created_at', 'DESC']],
      attributes: { exclude: ['password', 'deleted_at'] }
    })
  }
}
```

### 7.2 缓存策略
```javascript
// 🔴 Redis缓存管理
const redis = require('redis')

class CacheManager {
  constructor() {
    this.client = redis.createClient({
      host: process.env.REDIS_HOST,
      port: process.env.REDIS_PORT,
      password: process.env.REDIS_PASSWORD,
      retry_strategy: (options) => {
        if (options.error && options.error.code === 'ECONNREFUSED') {
          return new Error('Redis服务器连接被拒绝')
        }
        if (options.total_retry_time > 1000 * 60 * 60) {
          return new Error('Redis重试时间耗尽')
        }
        return Math.min(options.attempt * 100, 3000)
      }
    })
  }
  
  /**
   * 🔴 缓存抽奖配置
   */
  async cacheLotteryConfig(config) {
    const key = 'lottery:config'
    const ttl = 60 * 60 // 1小时过期
    
    await this.client.setex(key, ttl, JSON.stringify(config))
  }
  
  /**
   * 🔴 获取缓存的抽奖配置
   */
  async getLotteryConfig() {
    const key = 'lottery:config'
    const cached = await this.client.get(key)
    
    return cached ? JSON.parse(cached) : null
  }
  
  /**
   * 🔴 用户信息缓存
   */
  async cacheUserInfo(userId, userInfo) {
    const key = `user:${userId}`
    const ttl = 30 * 60 // 30分钟过期
    
    await this.client.setex(key, ttl, JSON.stringify(userInfo))
  }
  
  /**
   * 🔴 分布式锁实现
   */
  async acquireLock(key, timeout = 10000) {
    const lockKey = `lock:${key}`
    const lockValue = Date.now() + timeout
    
    const result = await this.client.set(lockKey, lockValue, 'PX', timeout, 'NX')
    return result === 'OK'
  }
  
  /**
   * 🔴 释放分布式锁
   */
  async releaseLock(key) {
    const lockKey = `lock:${key}`
    await this.client.del(lockKey)
  }
}
```

## 🧪 八、测试规范

### 8.1 单元测试标准
```javascript
// 🔴 单元测试框架配置
const { describe, it, beforeEach, afterEach } = require('mocha')
const { expect } = require('chai')
const sinon = require('sinon')

describe('UserService', () => {
  let userService
  let mockDb
  
  beforeEach(() => {
    userService = new UserService()
    mockDb = sinon.createStubInstance(User)
  })
  
  afterEach(() => {
    sinon.restore()
  })
  
  describe('createUser', () => {
    it('应该成功创建新用户', async () => {
      // Arrange
      const userData = {
        mobile: '13800138000',
        nickname: '测试用户'
      }
      
      mockDb.findOne.resolves(null) // 用户不存在
      mockDb.create.resolves({ user_id: 1, ...userData })
      
      // Act
      const result = await userService.createUser(userData)
      
      // Assert
      expect(result.user_id).to.equal(1)
      expect(result.mobile).to.equal(userData.mobile)
      expect(mockDb.create.calledOnce).to.be.true
    })
    
    it('应该拒绝创建重复用户', async () => {
      // Arrange
      const userData = { mobile: '13800138000' }
      mockDb.findOne.resolves({ user_id: 1 }) // 用户已存在
      
      // Act & Assert
      try {
        await userService.createUser(userData)
        expect.fail('应该抛出错误')
      } catch (error) {
        expect(error.message).to.equal('用户已存在')
      }
    })
  })
})
```

### 8.2 集成测试标准
```javascript
// 🔴 API集成测试
const request = require('supertest')
const app = require('../src/app')

describe('API Integration Tests', () => {
  let authToken
  
  before(async () => {
    // 获取测试用户的认证令牌
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        mobile: '13800138000',
        code: '123456'
      })
    
    authToken = loginResponse.body.data.access_token
  })
  
  describe('GET /api/lottery/config', () => {
    it('应该返回抽奖配置', async () => {
      const response = await request(app)
        .get('/api/lottery/config')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200)
      
      expect(response.body.code).to.equal(0)
      expect(response.body.data).to.have.property('prizes')
      expect(response.body.data.prizes).to.be.an('array')
    })
  })
  
  describe('POST /api/lottery/draw', () => {
    it('应该成功执行抽奖', async () => {
      const response = await request(app)
        .post('/api/lottery/draw')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          userId: 1,
          costPoints: 100
        })
        .expect(200)
      
      expect(response.body.code).to.equal(0)
      expect(response.body.data).to.have.property('prizeId')
    })
  })
})
```

## 🚀 九、部署运维规范

### 9.1 Docker容器化配置
```dockerfile
# 🔴 多阶段构建Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 🔴 生产环境镜像
FROM node:18-alpine AS production

# 安装dumb-init用于信号处理
RUN apk add --no-cache dumb-init

# 创建非root用户
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# 复制构建结果
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# 切换到非root用户
USER nodejs

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

# 暴露端口
EXPOSE 3000

# 启动应用
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/app.js"]
```

### 9.2 环境配置管理
```javascript
// 🔴 环境配置验证
const Joi = require('joi')

const envSchema = Joi.object({
  NODE_ENV: Joi.string()
    .valid('development', 'testing', 'production')
    .default('development'),
  
  PORT: Joi.number()
    .port()
    .default(3000),
  
  DB_HOST: Joi.string().required(),
  DB_PORT: Joi.number().port().default(3306),
  DB_NAME: Joi.string().required(),
  DB_USER: Joi.string().required(),
  DB_PASSWORD: Joi.string().required(),
  
  REDIS_HOST: Joi.string().required(),
  REDIS_PORT: Joi.number().port().default(6379),
  REDIS_PASSWORD: Joi.string().allow(''),
  
  JWT_SECRET: Joi.string().min(32).required(),
  JWT_EXPIRES: Joi.string().default('7d'),
  
  SMS_ACCESS_KEY: Joi.string().required(),
  SMS_SECRET_KEY: Joi.string().required(),
  
  SEALOS_ENDPOINT: Joi.string().uri().required(),
  SEALOS_ACCESS_KEY: Joi.string().required(),
  SEALOS_SECRET_KEY: Joi.string().required()
})

// 🔴 配置验证和加载
const { error, value: envVars } = envSchema.validate(process.env)

if (error) {
  throw new Error(`环境配置验证失败: ${error.message}`)
}

module.exports = envVars
```

## 📊 十、监控告警规范

### 10.1 健康检查端点
```javascript
// 🔴 健康检查实现
const healthCheck = {
  // 应用状态检查
  async checkApplication() {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version
    }
  },
  
  // 数据库连接检查
  async checkDatabase() {
    try {
      await sequelize.authenticate()
      return { status: 'healthy', responseTime: Date.now() }
    } catch (error) {
      return { status: 'unhealthy', error: error.message }
    }
  },
  
  // Redis连接检查
  async checkRedis() {
    try {
      const start = Date.now()
      await redis.ping()
      return { 
        status: 'healthy', 
        responseTime: Date.now() - start 
      }
    } catch (error) {
      return { status: 'unhealthy', error: error.message }
    }
  }
}

// 健康检查路由
app.get('/health', async (req, res) => {
  const checks = await Promise.all([
    healthCheck.checkApplication(),
    healthCheck.checkDatabase(),
    healthCheck.checkRedis()
  ])
  
  const [app, db, redis] = checks
  const allHealthy = checks.every(check => check.status === 'healthy')
  
  res.status(allHealthy ? 200 : 503).json({
    status: allHealthy ? 'healthy' : 'unhealthy',
    checks: { app, db, redis },
    timestamp: new Date().toISOString()
  })
})
```

### 10.2 告警规则配置
```javascript
// 🔴 告警规则定义
const ALERT_RULES = {
  // 响应时间告警
  responseTime: {
    threshold: 1000, // 1秒
    action: 'warn',
    message: 'API响应时间过长'
  },
  
  // 错误率告警
  errorRate: {
    threshold: 0.05, // 5%
    window: 300, // 5分钟窗口
    action: 'critical',
    message: '错误率过高'
  },
  
  // 内存使用告警
  memoryUsage: {
    threshold: 0.8, // 80%
    action: 'warn',
    message: '内存使用率过高'
  },
  
  // 数据库连接告警
  dbConnection: {
    threshold: 0, // 连接失败
    action: 'critical',
    message: '数据库连接失败'
  }
}
```

---

## 🎯 总结：后端技术规范文档价值

### ✅ 核心价值
1. **服务稳定性**：通过规范化的架构设计确保服务高可用
2. **开发效率**：标准化的开发流程提升团队协作效率
3. **安全保障**：完善的安全防护机制保护系统安全
4. **性能优化**：基于最佳实践的性能优化策略

### 🎯 实施路径
1. **基础设施**：首先建立数据库、缓存、日志等基础设施
2. **核心功能**：实现用户认证、权限管理等核心功能
3. **业务逻辑**：基于规范实现具体业务功能
4. **监控运维**：建立完善的监控告警体系

**文档定位**：后端开发工程师专用技术规范  
**覆盖范围**：Node.js后端服务开发全流程  
**更新策略**：随技术发展和业务需求持续优化 